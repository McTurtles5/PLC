function ge() return getgenv() end

--[[local latestver = tonumber(game:HttpGet("https://raw.githubusercontent.com/McTurtles5/PLC/main/PLC-resources/latestversion"))
local currentver = PLCver

if latestver and latestver > currentver then
	loadstring(game:HttpGet("https://raw.githubusercontent.com/McTurtles5/PLC/main/PLC-resources/updater"))()
end]]

ge().PLCdata.cmdreplace = { -- What commands to replace with name and aliases
	["pfastkill"] = {
		["Name"] = "k",
		["Aliases"] = {}
	},
	["ploopkill"] = {
		["Name"] = "loopkill",
		["Aliases"] = {"lk"}
	},
	["punloopkill"] = {
		["Name"] = "unloopkill",
		["Aliases"] = {"unlk"}
	},
	["pkill"] = {
		["Name"] = "tk",
		["Aliases"] = {"tkill"}
	},
	["pteamcolor"] = {
		["Name"] = "pteamcolor",
		["Aliases"] = {"teamc", "tc"}
	},
	["pteam"] = {
		["Name"] = "pteam",
		["Aliases"] = {"t"}
	},
	["pcrash"] = {
		["Name"] = "crash",
		["Aliases"] = {}
	},
	["pgetgun"] = {
		["Name"] = "getgun",
		["Aliases"] = {"gun", "item", "get"}
	},
	["phardrespawn"] = {
		["Name"] = "hardrespawn",
		["Aliases"] = {"hre"}
	},
	["pauto"] = {
		["Name"] = "auto",
		["Aliases"] = {"autore", "autorespawn"}
	},
	["pka"] = {
		["Name"] = "aura",
		["Aliases"] = {"killaura", "ka"}
	},
	["pfastpunch"] = {
		["Name"] = "fastpunch",
		["Aliases"] = {"superpunch", "fp"}
	},
	["psuperfastpunch"] = {
		["Name"] = "superfastpunch",
		["Aliases"] = {"fastsuperpunch", "sfp"}
	},
	["parmorgod"] = {
		["Name"] = "armorgod",
		["Aliases"] = {"agod"}
	},
	["pcriminal"] = {
		["Name"] = "criminal",
		["Aliases"] = {"crim"}
	},
	["parrest"] = {
		["Name"] = "arrest",
		["Aliases"] = {"ar"}
	},
	["pgive"] = {
		["Name"] = "give",
		["Aliases"] = {}
	}, 
	["pdeletshield"] = {
		["Name"] = "deletshield",
		["Aliases"] = {"noshield"}
	},
	["pgetcolor"] = {
		["Name"] = "getcolor",
		["Aliases"] = {"notifycolor"}
	},
	["pfastcar"] = {
		["Name"] = "fastcar",
		["Aliases"] = {"fsc"}
	},
	["pdamage"] = {
		["Name"] = "damage",
		["Aliases"] = {}
	},
	["p18+"] = {
		["Name"] = "18+",
		["Aliases"] = {"\112\112", "\68\65\68\68\89\73\84\83\66\73\71"} -- dont see what it says pls
	},
	["ploadout"] = {
		["Name"] = "loadout",
		["Aliases"] = {"getloadout"}
	},
	["psaveloadout"] = {
		["Name"] = "saveloadout",
		["Aliases"] = {"writeloadout"}
	},
	["pdeletloadout"] = {
		["Name"] = "deletloadout",
		["Aliases"] = {}
	},
	["ploadgunmod"] = {
		["Name"] = "loadgunmod",
		["Aliases"] = {"loadmod"}
	},
	["pgunwithgunmod"] = {
		["Name"] = "gunwithgunmod",
		["Aliases"] = {"gunwithgunmod", "loadgunwithgunmod", "gunwmod"}
	},
	["psavegunmod"] = {
		["Name"] = "savegunmod",
		["Aliases"] = {}
	},
	["pdeletgunmod"] = {
		["Name"] = "deletgunmod",
		["Aliases"] = {}
	},
	["pfixfade"] = {
		["Name"] = "fixfade",
		["Aliases"] = {"restorefade"}
	},
	["ptase"] = {
		["Name"] = "tase",
		["Aliases"] = {}
	},
	["pmodgun"] = {
		["Name"] = "modgun",
		["Aliases"] = {}
	},
	["pspread"] = {
		["Name"] = "gunspread",
		["Aliases"] = {"spread"}
	},
	["prange"] = {
		["Name"] = "gunrange",
		["Aliases"] = {"range"}
	},
	["pnoreloadtime"] = {
		["Name"] = "noreloadtime",
		["Aliases"] = {"fastreload", "fastr"}
	},
	["pinfammo"] = {
		["Name"] = "infammo",
		["Aliases"] = {}
	},
	["pswatak"] = {
		["Name"] = "swatak",
		["Aliases"] = {"fakem4", "fakem4a1", "bootlegm4a1", "bootlegm4"}
	},
	["pearape"] = {
		["Name"] = "earape",
		["Aliases"] = {"loudnoise", "loud"}
	},
	["padmin"] = {
		["Name"] = "admin",
		["Aliases"] = {}
	},
	["punadmin"] = {
		["Name"] = "unadmin",
		["Aliases"] = {}
	},
	["pgetadmins"] = {
		["Name"] = "getadmins",
		["Aliases"] = {"chatnotifyadmins"}
	},
	["pgetloadouts"] = {
		["Name"] = "getloadouts",
		["Aliases"] = {"chatnotifyloadouts"}
	},
	["pgetgunmods"] = {
		["Name"] = "getgunmods",
		["Aliases"] = {"chatnotifygunmods"}
	},
	["pcar"] = {
		["Name"] = "car",
		["Aliases"] = {"spawncar", "summoncar"}
	},
	["pdeletcar"] = {
		["Name"] = "deletecar",
		["Aliases"] = {"removecar", "deletcar"}
	},
	["ptogglefastbring"] = {
		["Name"] = "togglefastbring",
		["Aliases"] = {"turnfastbring", "tfb"}
	},
	["pfasteat"] = {
		["Name"] = "fasteat",
		["Aliases"] = {"hungry"}
	},
	["pantitase"] = {
		["Name"] = "antitase",
		["Aliases"] = {"notase", "tase=bad"}
	},
	["panticrash"] = {
		["Name"] = "anticrash",
		["Aliases"] = {"nocrash"}
	},
	["pcamlookat"] = {
		["Name"] = "camlookat",
		["Aliases"] = {}
	},
	["pvirus"] = {
		["Name"] = "virus",
		["Aliases"] = {}
	},
	["punvirus"] = {
		["Name"] = "unvirus",
		["Aliases"] = {"cure"}
	},
	["pgiveaura"] = {
		["Name"] = "giveaura",
		["Aliases"] = {}
	},
	["premoveaura"] = {
		["Name"] = "removeaura",
		["Aliases"] = {}
	},
	["pjoinjobid"] = {
		["Name"] = "joinjobid",
		["Aliases"] = {}
	},
	["pkey"] = {
		["Name"] = "key",
		["Aliases"] = {}
	},
	["pclickkill"] = {
		["Name"] = "clickkill",
		["Aliases"] = {"ck"}
	},
	["panticrim"] = {
		["Name"] = "anticrim",
		["Aliases"] = {"nocrim"}
	},
	["pantibring"] = {
		["Name"] = "antibring",
		["Aliases"] = {"nobring", "ab"}
	},
}

ge().PLCdata.warning = "Warning, changing values in here can cause PLC to break so only read values pls"
ge().PLCdata.RenderConnections = ge().PLCdata.RenderConnections or {}
ge().PLCdata.lastloadout = nil
ge().PLCdata.lastgunmod = nil
ge().PLCdata.loadout = { -- Your loadout
	[1] = "M9";
	[2] = 0;
	[3] = 0;
	[4] = "Remington 870";
	[5] = "M4A1";
}

ge().PLCegg = "you are gameing"
local g = ge()
function g.PLCeggvirus()
	local s = Instance.new("Sound", game:GetService("SoundService"))
	s.Looped = true
	s.SoundId = "rbxassetid://5287139449"
	wait(3)
	s:Play()
	s.PlaybackSpeed = 1.25
end

--[[
template
		["cmd name"] = {
			["Description"] = "description",
			["Aliases"] = {"cmd similars"},
			["Function"] = function(args, speaker)
				
			end,
		},
]]

local RS = game:GetService("RunService")
local isPL = game.PlaceId == 155615604
if not game.IsLoaded then
	game.Loaded:Wait()
end

if not ge().PLCdata.mapParts then
	ge().PLCdata.mapParts = {
		["roof"] = {},
		["walls"] = {}
	}
end

local active = true

local function addParts(t, model, name, class)
	class = class or "BasePart"
	for _, part in pairs(model:GetChildren()) do
		if part.Name == name and part.ClassName == class then
			table.insert(ge().PLCdata.mapParts[t], {part, part.Parent})
		end
	end
end

local function addSubParts(t, model, name)
	for _, mod in pairs(model:GetChildren()) do
		if mod:IsA("Model") then
			for _, part in pairs(mod:GetChildren()) do
				if part.Name == name and part:IsA("BasePart") then
					table.insert(ge().PLCdata.mapParts[t], {part, part.Parent})
				end
			end
		end
	end
end

if isPL then
	addParts("roof", workspace:WaitForChild("Prison_Halls").roof, "Part", "Part")
	addParts("roof", workspace:WaitForChild("Prison_Cafeteria"), "Wedge", "WedgePart")
	addParts("roof", workspace.Prison_Cafeteria, "Floor", "Part")
	addParts("roof", workspace:WaitForChild("Prison_Cellblock"), "Wedge", "WedgePart")
	addParts("roof", workspace.Prison_Cellblock, "c_ceiling", "Part")
	addParts("roof", workspace:WaitForChild("Prison_Administration"), "Part", "Part")
	addParts("roof", workspace:WaitForChild("Prison_Guard_Outpost"), "Part", "Part")

	addParts("roof", workspace.Prison_Halls.lights, "Light", "Part")
	addParts("roof", workspace.Prison_Cellblock.c_lights.Model, "back", "Part")
	addParts("roof", workspace.Prison_Administration.light_floor1, "Light", "Part")
	addParts("roof", workspace.Prison_Administration.light_floor2, "realLight", "Part")
	addParts("roof", workspace.Prison_Cellblock.c_lights, "Light", "Part")

	addSubParts("roof", workspace.Prison_Halls.lights, "Light")
	addSubParts("roof", workspace.Prison_Guard_Outpost.lights, "Light")
	addSubParts("roof", workspace.Prison_Administration, "Light")
	addSubParts("roof", workspace.Prison_Cafeteria, "Floor")


	addParts("walls", workspace.Prison_Halls.walls, "part", "Part")
	addParts("walls", workspace.Prison_Halls.glass, "part", "Part")
	addParts("walls", workspace.Prison_Halls.accent, "part", "Part")
	addParts("walls", workspace.Prison_Cafeteria.building, "Part", "Part")
	addParts("walls", workspace.Prison_Cafeteria.accents, "Part", "Part")
	addParts("walls", workspace.Prison_Cafeteria.doorway, "Part", "Part")
	addParts("walls", workspace.Prison_Cafeteria.glass, "Part", "Part")
	addParts("walls", workspace.Prison_Cafeteria.glassdividers, "Part", "Part")
	addParts("walls", workspace.Prison_Administration, "trimboi", "Part") -- trimboi XD

	addParts("walls", workspace.Prison_Cellblock, "c_hallwall", "Part")
	addParts("walls", workspace.Prison_Guard_Outpost.wall, "part", "Part")
	addParts("walls", workspace.Prison_Administration.walls, "part", "Part")
	addParts("walls", workspace.Prison_Administration.front, "part", "Part")
	addParts("walls", workspace.Prison_Halls.outlines, "c_floor", "Part")
	addParts("walls", workspace.Prison_Cellblock.b_front, "Part", "Part")
	addParts("walls", workspace.Prison_Cellblock.b_wall, "wall", "Part")
	addParts("walls", workspace.Prison_Cellblock.b_outerwall, "Part", "Part")
	addParts("walls", workspace.Prison_Cellblock.b_outerwall.Bars.bot, "Part", "Part")
	addParts("walls", workspace.Prison_Cellblock.b_outerwall.Bars, "Part", "Part")
	addParts("walls", workspace.Prison_Cellblock.doors, "b_door", "UnionOperation")
	addParts("walls", workspace.Prison_Cellblock.b_front.glass, "Part", "Part")
	addParts("walls", workspace.Prison_Cellblock.c_wall, "Part", "Part")
	addParts("walls", workspace.Prison_Cellblock, "c_corner", "WedgePart")
	addParts("walls", workspace.Prison_Cellblock.a_front, "Part", "Part")
	addParts("walls", workspace.Prison_Cellblock.a_walls, "wall", "Part")
	addParts("walls", workspace.Prison_Cellblock.a_outerwall, "Part", "Part")
	addParts("walls", workspace.Prison_Cellblock.a_outerwall.Bars.bot, "Part", "Part")
	addParts("walls", workspace.Prison_Cellblock.a_outerwall.Bars, "Part", "Part")
	addParts("walls", workspace.Prison_Cellblock.doors, "a_door", "UnionOperation")
	addParts("walls", workspace.Prison_Cellblock.a_front.glass, "Part", "Part")
	addParts("walls", workspace.Prison_Cellblock.c_wall, "Part", "Part")
	addParts("walls", workspace.Prison_Guard_Outpost.doorwindow, "hitbox", "Part")

	addSubParts("walls", workspace.Prison_Guard_Outpost, "part", "Part")
	addSubParts("walls", workspace.Prison_Administration.walls, "part", "Part")
	addSubParts("walls", workspace.Prison_Cafeteria.Model, "Part", "Part")
end

local possibleTeams = {
	{"Guards", "Bright blue"},
	{"Inmates", "Bright orange"},
	{"Criminals", "Really red"},
	{"Neutral", "Medium stone grey"},
}

local possibleItems = {
	"M9",
	"AK-47",
	"Crude Knife",
	"Hammer",
	"Remington 870",
	"M4A1",
	"Key card"
}

local hostileItems = {
	"M9",
	"AK-47",
	"Crude Knife",
	"Hammer",
	"Remington 870",
	"M4A1"
}

local function isHostile(plr)
	if plr:FindFirstChildOfClass("Backpack") then
		for _, v in pairs(plr.Backpack:GetChildren()) do
			if table.find(hostileItems, v.Name) then
				return true
			end
		end
	end
	if plr.Character then
		for _, v in pairs(plr.Character:GetChildren()) do
			if table.find(hostileItems, v.Name) then
				return true
			end
		end
	end
	if plr:FindFirstChild("Status") and plr.Status:FindFirstChild("isHostile") and  plr.Status.isHostile.Value then
		return true
	end
	return 
end

local function Sound(snd, p)
	if not p then
		p = snd.Parent
	end
	local snd2 = snd:Clone()
	snd2.Playing = true
	snd2.TimePosition = 0
	snd2.Parent = p
	game:GetService("Debris"):AddItem(snd2, snd2.TimeLength + 1)
	game:GetService("ReplicatedStorage").SoundEvent:FireServer(snd, p)
end

local function Touch(part, with)
	if firetouchinterest then
		coroutine.resume(coroutine.create(function()
			firetouchinterest(part, with, 1)
			RS.Stepped:Wait()
			firetouchinterest(part, with, 0)
		end))
	else
		notify("Incompatible Exploit","Your exploit does not support this command (missing firetouchinterest) this is needed for some commands to work")
	end
end

function isArrestable(plr)
	print(tostring(plr.TeamColor))
	if tostring(plr.TeamColor) == "Really red" then
		return true
	elseif tostring(plr.TeamColor) == "Bright orange" then
		local part = plr.Character and (plr.Character:FindFirstChild("HumanoidRootPart") or plr.Character:FindFirstChildOfClass("BasePart"))
		if part then
			local ar = true
			local regions = game:GetService("ReplicatedStorage").PermittedRegions
			local regparts = game:GetService("ReplicatedStorage").Regions
			local parts = {}
			local names = {}
			for _, v in pairs(regions:GetChildren()) do
				table.insert(names, v.Value)
			end
			for _, part in pairs(regparts:GetChildren()) do
				if table.find(names, part.Name) then
					table.insert(parts, part)
				end
			end
			for _, region in pairs(parts) do
				if table.find(workspace:GetPartBoundsInBox(region.CFrame, region.Size), part) then
					ar = false
					break
				end
			end
			return ar
		end
	end
	return
end

local function Criminal(plr)
	for _, part in pairs(plr.Character:GetChildren()) do
		if part:IsA("BasePart") then
				local spawn = workspace["Criminals Spawn"].SpawnLocation
				local c = spawn.CanTouch
			coroutine.resume(coroutine.create(function()
				spawn.CanTouch = true
				Touch(spawn, part, 1)
				RS.Stepped:Wait()
				Touch(spawn, part, 0)
				spawn.CanTouch = c
			end))
		end
	end
end

local function Team(arg, speaker)
	local teamRemote = workspace.Remote.TeamEvent
	local Team = nil
	local TeamColor = nil
	for _, found in pairs(possibleTeams) do
		if string.sub(found[1]:lower(), 1, arg:len()) == arg:lower() then
			Team = found[1]
			TeamColor = found[2]
			break
		end
	end
	if Team then
		if Team == "Criminals" then
			Criminal(speaker)
		else
			teamRemote:FireServer(TeamColor)
		end
	end
end

local function TeamColor(speaker, args, spawnpos)
	local function team(color)
		local Char = speaker.Character
		local pos = Char:WaitForChild("HumanoidRootPart").CFrame
		workspace.Remote.loadchar:InvokeServer(Player, color)
		Char = speaker.Character
		Char:WaitForChild("HumanoidRootPart").CFrame = spawnpos or pos
	end
	local color = table.concat(args, " ")
	local num = tonumber(color)
	local brick = BrickColor.new(color)
	if num then
		team(tostring(brick))
	else
		if brick and string.lower(tostring(brick)) == string.lower(color) then
			team(color)
		elseif color:lower() == "random" then
			local color2 = nil
			repeat
				local new = tostring(BrickColor.random())
				for _, team in pairs(possibleTeams) do
					if new ~= team[2] and new ~= tostring(Players.LocalPlayer.TeamColor) then
						color2 = new
					end
				end
			until color2
			team(color2)
		else
			notify("Invalid", "'"..color.."' is not a brick color. (Case sensetive)")
		end
	end
end

local function getPlaceHolder()
	local holder = Instance.new("Tool", Players.LocalPlayer:WaitForChild("Backpack"))
	holder.Name = "PLACE_HOLDER"
	return holder
end

local function Round(frame)
	local v = frame.Position
	local x, y, z = math.floor(v.X / 5) * 5, math.floor(v.Y / 5) * 5, math.floor(v.Z / 5) * 5
	return Vector3.new(x, y, z)
end

local function IsArrested(plr)
	if plr.Character then
		local head = plr.Character:FindFirstChild("Head")
		if head then
			local arrestui = head:FindFirstChild("handcuffedGui")
			if arrestui then
				return true
			end
		end
	end
	return
end

local function Respawn(spawnpos)
	local camtrackback = 4
	local plr = Players.LocalPlayer
	local char = plr.Character
	local pos = nil
	local vel = nil
	local camframe = nil
	local root = getRoot(char) or char:FindFirstChildOfClass("BasePart")
	local Neutral = plr.Team == game:GetService("Teams"):WaitForChild("Neutral")
	local trackcam = true
	local track = nil
	local camtracks = {}
	local currentsub = workspace.CurrentCamera.CameraSubject
	local last = nil
	if workspace.CurrentCamera then
		camframe = workspace.CurrentCamera.CFrame
	end
	pcall(function()
		pos = spawnpos or root.CFrame
		function update()
			if not root or not root.Parent or root == nil or root.Parent == nil then
				track:Disconnect()
				return
			end
			if not spawnpos then
				pos = root.CFrame
			end
			last = workspace.CurrentCamera.CFrame
			camframe = workspace.CurrentCamera.CFrame
			if trackcam and workspace.CurrentCamera and workspace.CurrentCamera.CameraSubject == currentsub and currentsub then
				table.insert(camtracks, workspace.CurrentCamera.CFrame)
			end
			vel = root.Velocity
		end
		track = RS.RenderStepped:Connect(update)
		update()
	end)
	if IsArrested(plr) then
		if track then
			track:Disconnect()
		end
		char:BreakJoints()
		local current = plr.Character
		while current and current.Parent and current ~= nil and current.parent ~= nil do
			RS.RenderStepped:Wait()
		end
	else
		workspace.Remote.loadchar:InvokeServer("\110\111\111\111\111\111\32\58\40", Neutral and "Bright orange")
	end
	trackcam = false
	while not plr.Character do
		RS.RenderStepped:Wait()
	end
	if track then
		track:Disconnect()
	end
	char = plr.Character
	if not char.PrimaryPart then
		char:GetPropertyChangedSignal("PrimaryPart"):Wait()
	end
	root = getRoot(char) or char:FindFirstChildOfClass("BasePart")
	local hum = char:FindFirstChildOfClass("Humanoid")

	game:GetService("StarterGui"):SetCoreGuiEnabled("Backpack", true)
	if Neutral then
		Team("n")
	end
	camframe = camtracks[math.max(1, #camtracks - camtrackback)]
	pcall(function()
		if pos then
			local cs = 0
			repeat
				local root = getRoot(char) or char:FindFirstChildOfClass("BasePart")
				root.CFrame = pos
				if workspace.CurrentCamera and camframe then
					workspace.CurrentCamera.CFrame = camframe
				end
				RS.RenderStepped:Wait()
				root.Velocity = Vector3.new(0, 0, 0)
				if (root.CFrame.Position - pos.Position).magnitude < 5 then
					cs = cs + 1
				end
			until cs >= 10
		end
		if hum then
			hum:ChangeState(2)
		end
	end)
	pcall(function()
		if vel then
			root.Velocity = vel
		end
	end)
	if workspace.CurrentCamera and camframe then
		workspace.CurrentCamera.CFrame = camframe
	end
end

local function IsAlive(plr)
	if plr.Character then
		local hum = plr.Character:FindFirstChildOfClass("Humanoid")
		if hum then
			if hum.Health > 0 then
				return true, hum.Health
			end
		end
	end
	return
end

local function IsVulnerable(plr)
	if plr.Character then
		if plr.Character:FindFirstChildOfClass("ForceField") then
			return
		end
	end
	return true
end

local function IsClose(plr, speaker, dist)
	if plr.Character then
		dist = dist or 20
		local hrp = getRoot(speaker.Character) or speaker.Character:FindFirstChildOfClass("BasePart")
		local hrp2 = getRoot(plr.Character) or plr.Character:FindFirstChildOfClass("BasePart")
		if hrp and hrp2 then
			if (hrp2.Position - hrp.Position).magnitude <= dist then
				return true
			end
		end
	end
	return
end

local function IsSitting(plr)
	if plr.Character then
		local hum = plr.Character:FindFirstChildOfClass("Humanoid")
		if hum then
			if hum.Sit then
				return true
			end
		end
	end
	return
end

--[[local function IsSwat(speaker)
	local has = true
	local http = game:GetService("HttpService")
	local json = game:HttpGet("https://inventory.roblox.com/v1/users/"speaker.UserId"/items/GamePass/96651")
	local data = http:JSONDecode(json)
	if data["errors"] == nil then
		has = data["data"][1] ~= nil
	end
	return has
end]]

local function press(key, del)
	if keypress and keyrelease then
		keypress(key)
		wait(del)
		keyrelease(key)
	else
		wait(del)
	end
end

local whitelisted = nil

local function attach(speaker, target, requesttool) -- Modified IY attach
	if tools(speaker) then
		local name = target.Name
		local char = speaker.Character
		local tchar = target.Character
		local hum = speaker.Character:FindFirstChildOfClass("Humanoid")
		hum:ChangeState("Ragdoll", false)
		local hrp = getRoot(speaker.Character)
		local hrp2 = getRoot(target.Character)
		hum.Name = "1"
		local newHum = hum:Clone()
		newHum.Parent = char
		newHum.Name = "Humanoid"
		hum:Destroy()
		workspace.CurrentCamera.CameraSubject = char
		newHum.DisplayDistanceType = "None"
		local tool = requesttool or speaker.Character:FindFirstChildOfClass("Tool") or speaker:FindFirstChildOfClass("Backpack"):FindFirstChildOfClass("Tool")
		whitelisted = tool
		tool.Parent = char
		local function rp()
			hrp.CFrame = hrp2.CFrame * CFrame.new(0, 0, 0) * CFrame.new(math.random(-100, 100)/200,math.random(-100, 100)/200,math.random(-100, 100)/200) * CFrame.Angles(0, math.rad(math.random(-180, 180)), math.rad(math.random(-180, 180))) * CFrame.new(0, -1, 0)
		end
		rp()
		local start = os.clock()
		repeat RS.RenderStepped:Wait()
			rp()
		until (tool.Parent ~= char or not hrp or not hrp2 or not hrp.Parent or not hrp2.Parent or (start + 4) < os.clock() or target ~= Players[name]) and (start + 0.2) < os.clock()
	end
end

local function getGun(speaker, name, pickup)
	name = name or "Remington 870"
	function get()
		local arg = pickup or workspace.Prison_ITEMS.giver:FindFirstChild(name).ITEMPICKUP
		workspace.Remote.ItemHandler:InvokeServer(arg)
		return speaker.Backpack:FindFirstChild(name)
	end
	return speaker.Backpack:FindFirstChild(name) or speaker.Character:FindFirstChild(name) or get()
end

--[[if not (keypress and keyrelease) then
	notify("Incompatible Exploit", "Your exploit does not support this command (missing keypress / keyrelase) and teleport commands may not work properly")
end]]

local function fastCriminal(speaker, target)
	Respawn()
	local root = speaker.Character and (getRoot(speaker.Character) or speaker.Character:FindFirstChildOfClass("BasePart"))
	local pos = root and root.CFrame
	local tool = getGun(speaker, "Hammer", workspace.Prison_ITEMS.single:FindFirstChild("Hammer").ITEMPICKUP)
	attach(speaker, target, tool)
	Criminal(target)
	local timeout = os.clock() + 3
	while timeout > os.clock() and target.Team ~= game:GetService("Teams").Criminals do
		RS.Stepped:Wait()
	end
	Respawn(pos)
end

local function prisonteleport(speaker, target, targetpos, norespawn) -- Modified IY play teleport
	local arg = workspace.Prison_ITEMS.single:FindFirstChild("Hammer").ITEMPICKUP
	if target ~= nil and IsAlive(target) and not IsSitting(target) then
		if not ge().PLCdata.fastbring then

			local beat = RS.Heartbeat
			local NormPos = getRoot(speaker.Character).CFrame
			local ping = os.clock()
			workspace.Remote.loadchar:InvokeServer()
			ping = os.clock() - ping
			local ping2 = elapsedTime()
			workspace.Remote.ItemHandler:InvokeServer(arg)
			ping2 = os.clock() - ping2
			ping = math.clamp((ping + ping2) / 2 + 0.8, 0.1, 5)
			repeat beat:Wait() until speaker.Character ~= nil and getRoot(speaker.Character)
			local hrp = getRoot(speaker.Character)
			local waiting = true
			local WT = os.clock() + 4
			local tool = nil
			coroutine.resume(coroutine.create(function()
				tool = attach(speaker, target)
				waiting = false
				repeat beat:Wait()
					hrp.CFrame = targetpos
				until not getRoot(target.Character) or not getRoot(speaker.Character)
			end))
			repeat
				beat:Wait()
				if os.clock() > WT then
					waiting = false
				end
			until not waiting
			speaker.Character:FindFirstChildOfClass("Humanoid"):MoveTo(Vector3.new(99999999, 999999999, 99999999))
			--coroutine.resume(coroutine.create(function()
			--	repeat wait(0.5)
			--		press(0x57, 0.5)
			--	until not hrp or not hrp.Parent or hrp == nil or hrp.Parent == nil
			--end))
			if respawn then
				wait(0.5)
				Respawn(NormPos)
			end
			return


		else

			local plr = Players.LocalPlayer
			local current = plr.Character.HumanoidRootPart.CFrame
			plr.Character.Humanoid.Sit = false
			local tool = plr.Character:FindFirstChildOfClass("Tool") or plr:FindFirstChildOfClass("Backpack"):FindFirstChildOfClass("Tool") or getGun(plr)
			local hum = plr.Character.Humanoid
			local newHum = hum:Clone()
			newHum.Parent = hum.Parent
			newHum.Name = "1"
			hum:Destroy()
			workspace.CurrentCamera.CameraSubject = plr.Character
			newHum.DisplayDistanceType = "None"
			wait()
			plr.Character.Animate.Disabled = false
			newHum.DisplayDistanceType = "None"
			tool.Parent = plr.Character
			plr.Character.HumanoidRootPart.CFrame = targetpos
			local WT = elapsedTime() + 2
			local passedTool = false
			repeat RS.RenderStepped:Wait()
				plr.Character.HumanoidRootPart.CFrame = targetpos
				target.Character.HumanoidRootPart.CFrame = targetpos * CFrame.new(1, -1, 0)
				if tool.Parent ~= plr.Character then
					delay(0.2, function()
						passedTool = true
					end)
				end
			until not plr.Character or not target.Character or elapsedTime() > WT or passedTool
			if not norespawn then
				Respawn(current)
			end

		end
	else
		notify("Can't teleport", "Target is nil/dead/sitting")
	end
end

local autore = false
local autorecon = Players.LocalPlayer.CharacterAdded:Connect(function(char)
	local hum = char:WaitForChild("Humanoid")
	hum.Died:Connect(function()
		if autore then
			Respawn()
		end
	end)
end)

local kacon = nil
local ka = false
local function Killaura(speaker)
	if not ka then
		ka = true
		kacon = RS.Heartbeat:Connect(function()
			for _, plr in pairs(game:GetService("Players"):GetPlayers()) do
				if IsAlive(plr) and IsVulnerable(plr) and IsClose(plr, speaker) and plr ~= speaker then
					for _ = 1, 2 do
						game.ReplicatedStorage['meleeEvent']:FireServer(plr)
					end
				end
			end
		end)
	end
end

local anticrim = false
local last = "Really black"
local anticrimcon = Players.LocalPlayer:GetPropertyChangedSignal("TeamColor"):Connect(function()
	local color = tostring(Players.LocalPlayer.TeamColor)
	if anticrim and color == "Really red" then --                                                                                                          hello
		local move = nil
		local dir = nil
		local dist = 10
		local char = Players.LocalPlayer.Character
		local root = getRoot(char) or char:FindFirstChildOfClass("BasePart")
		local cur = root.CFrame
		local arm = char:FindFirstChild("Right Arm") or char:FindFirstChild("RightHand")
		local con = nil
		if arm then
			arm:BreakJoints()
		end
		Players.LocalPlayer.Character:BreakJoints()
		con = RS.RenderStepped:Connect(function()
			root.CFrame = CFrame.new(math.random(0, 9999999), math.random(0, 9999999), math.random(0, 9999999))
			if char ~= Players.LocalPlayer.Character then
				con:Disconnect()
			end
		end)
		for _, spawn in pairs(workspace["Criminals Spawn"]:GetChildren()) do
			if spawn:IsA("Part") then
				local root = getRoot(Players.LocalPlayer.Character) or Players.LocalPlayer.Character:FindFirstChildOfClass("BasePart")
				if (spawn.Position - root.Position).magnitude < dist then
					move = spawn.Position
					dir = root.Position
					break
				end
			end
		end
		TeamColor(Players.LocalPlayer, {last}, cur)
		if move then
			local root = getRoot(Players.LocalPlayer.Character) or Players.LocalPlayer.Character:FindFirstChildOfClass("BasePart")
			root.CFrame = root.CFrame * CFrame.new(CFrame.new(move, dir).LookVector * 50)
		end
	else
		last = color
	end
end)

local function getTools(char, ignore)
	local tools = {}
	for _, tool in pairs(char:GetChildren()) do
		if tool:IsA("Tool") and tool ~= ignore then
			table.insert(tools, tool)
		end
	end
	return tools
end

local lockdownmode = false
local function lockdownDetect(plr)
	if active and plr ~= Players.LocalPlayer and getconnections and lockdownmode then
		coroutine.resume(coroutine.create(function()
			if plr.Character then
				local hum = plr.Character:WaitForChild("Humanoid")
				local con
				con = hum:GetPropertyChangedSignal("Parent"):Connect(function(p)
					if p == nil then
						con:Disconnect()
						Respawn()
						-- add stuff here
						--[[local function t(tool)
							if tool:IsA("Tool") then
								local h = tool:FindFirstChild("Handle")
								if h then
									local connections = getconnections(h.Touched)
									for _, con in pairs(connections) do
										con:Disable()
									end
								end
							end
						end
						for _, tool in pairs(plr.Character:GetChildren()) do
							t(tool)
						end
						plr.Character.ChildAdded:Connect(t)]]
					end
				end)
			end
		end))
	end
end

for _, plr in pairs(Players:GetPlayers()) do
	lockdownDetect(plr)
	plr.CharacterAdded:Connect(function()
		lockdownDetect(plr)
	end)
end

Players.PlayerAdded:Connect(function(plr)
	plr.CharacterAdded:Connect(function()
		lockdownDetect(plr)
	end)
end)

local antibring = false
local lastbackpack = {}

local antibringcon = Players.LocalPlayer.CharacterAdded:Connect(function(char)
	local root =  getRoot(char) or char:FindFirstChildOfClass("BasePart") or char:WaitForChild("HumanoidRootPart")
	local lastpos = root.CFrame
	char.ChildAdded:Connect(function(c)
		if c:IsA("Tool") and antibring then
			local handle = c:FindFirstChild("Handle")
			if handle then
				handle:BreakJoints()
			end
			c.Parent = Players.LocalPlayer:FindFirstChildOfClass("Backpack")
		end
	end)
	repeat
		if antibring and char then
			local t = char:FindFirstChildOfClass("Tool")
			root = getRoot(char) or char:FindFirstChildOfClass("BasePart")
			for _, v in pairs(lastbackpack) do
				if t == v and v:IsA("Tool") then
					whitelisted = v
					break
				end
			end
			lastbackpack = Players.LocalPlayer.Backpack:GetChildren()
			if t and root and t ~= whitelisted then
				local found = getTools(char, whitelisted)
				for _, tool in pairs(found) do
					tool.Parent = Players.LocalPlayer.Backpack
					tool.Name = "waste ("..tool.Name..")"
					tool:Destroy()
				end
				local current = root.CFrame			
				root.CFrame = lastpos
				local hum = char:FindFirstChildOfClass("Humanoid")
				if hum then
					hum:ChangeState(2)
				end
				local pos = Vector3.new(
					math.floor(current.Position.X + 0.5),
					math.floor(current.Position.Y + 0.5),
					math.floor(current.Position.Z + 0.5)
				)
				local amt = (#found > 1 and " ("..#found..") ") or ""
				local extra = ((root.CFrame.Position - pos).magnitude > 10 and "\n("..tostring(pos)..")") or ""
				notify("Bring blocked", "Anti-bring prevented a bring"..amt..extra)
			else
				lastpos = root.CFrame
			end
		end
		RS.RenderStepped:Wait()
	until not char or not char.Parent
end)

local function HasItem(name, plr)
	local found = plr.Backpack:FindFirstChild(name) or plr.Character:FindFirstChild(name)
	return found
end

local function GunKill(players)
	if type(players) ~= "table" then
		players = {players}
	end
	if 0 > #players then
		return
	end
	local Gun = getGun(Players.LocalPlayer)
	local args = {
		[1] = {},
		[2] = Gun,
	}
	for i, v in ipairs(players) do
		local target = Players[v]
		local alive, health = IsAlive(target)
		if IsVulnerable(target) and alive and target ~= Players.LocalPlayer and target.TeamColor ~= Players.LocalPlayer.TeamColor then
			local head = target.Character:FindFirstChild("Head")
			if head then
				local hitargs = {
					["RayObject"] = Ray.new(Vector3.new(827.41241455078, 101.48977661133, 2296.8432617188), Vector3.new(277.73867797852, 6.8934092521667, 287.7737121582)),
					["Distance"] = 4.7204174995422,
					["Cframe"] = CFrame.new(Vector3.new(832.04937744141, 101.39200592041, 2300.9716796875), Vector3.new(-0.53363537788391, -0.10343056917191, -0.83936601877213)),
					["Hit"] = head
				}
				for _ = 1, math.floor(health / 23) + 1 do
					args[1][#args[1]+1] = hitargs
				end
			end
		end
	end
	if #args[1] > 0 then
		game:GetService("ReplicatedStorage").ShootEvent:FireServer(unpack(args))
		game:GetService("ReplicatedStorage").ReloadEvent:FireServer(Gun)
	end
end
ge().PLCdata.loopkillprocess = {}
local loopkillcon = RS.Stepped:Connect(function()
	if #ge().PLCdata.loopkillprocess > 0 then
		GunKill(ge().PLCdata.loopkillprocess)
		table.clear(ge().PLCdata.loopkillprocess)
	end
end)

local function spike()
	local Gun = getGun(Players.LocalPlayer, "AK-47")
	local hitargs = {
		["RayObject"] = Ray.new(Vector3.new(827.41241455078, 101.48977661133, 2296.8432617188), Vector3.new(277.73867797852, 6.8934092521667, 287.7737121582)),
		["Distance"] = 4.7204174995422,
		["Cframe"] = CFrame.new(Vector3.new(832.04937744141, 101.39200592041, 2300.9716796875), Vector3.new(-0.53363537788391, -0.10343056917191, -0.83936601877213)),
		["Hit"] = head
	}
	local args = {
		[1] = hitargs,
		[2] = Gun,
	}
	game:GetService("ReplicatedStorage").ShootEvent:FireServer(unpack(args))
end

local timeout = false
local timeoutcon = RS.Stepped:Connect(function()
	if timeout then
		spike()
	end
end)

local loudsound = false
local function loud()
	if loudsound then return end
	loudsound = true
	local s = workspace["Prison_guardspawn"].spawn.Sound
	local last = os.clock()
	coroutine.resume(coroutine.create(function()
		repeat
			RS.Stepped:Wait()
			if os.clock() - last > 0.04 then
				last = os.clock()
				for _, p in pairs(Players:GetPlayers()) do
					local c = p.Character
					if c then
						local head = c:FindFirstChild("Head") or c:FindFirstChildOfClass("BasePart")
						if head then
							Sound(s, head)
						end
					end
				end
			end
		until not loudsound
	end))
end

local function Kill(plr)
	for i = 1, 14 do
		game.ReplicatedStorage['meleeEvent']:FireServer(plr)
	end
end

local function Goto(plr, Char)
	Char.Humanoid.Sit = false
	local root2 = getRoot(plr.Character) or plr.Character:FindFirstChildOfClass("BasePart")
	local frame = root2.CFrame * CFrame.new(0, 5, -2)
	local root = getRoot(Char) or Char:FindFirstChildOfClass("BasePart")
	Char.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
	Char:SetPrimaryPartCFrame(frame)
end

local function savemod(gun, type, value)
	local mod = gun:FindFirstChild("GunStates")
	local data = require(mod)
	if not data["PLCModifications"] then
		data["PLCModifications"] = {
			["Firerate"] = "N",
			["BulletAmount"] = "N",
			["Spread"] = "N",
			["Range"] = "N",
			["NoReloadtime"] = false
		}
	end
	data["PLCModifications"][type] = value
end

local innocents = {}

local function isSafe(hit, safe)
	return table.find(safe, hit and hit.Parent and hit.Parent.Name) or table.find(safe, hit and hit.Parent and hit.Parent.Parent and hit.Parent.Parent.Name) 
end

local function Chat(msg)
	game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(msg, "All")
end

ge().PLCdata.dmgmul = ge().PLCdata.dmgmul or 1
if isPL and (not ge().PLCdata.nohit and getrawmetatable and setreadonly) then
	ge().PLCdata.nohit = ge().PLCdata.nohit or {}
	local gt = getrawmetatable(game)
	local last = gt.__namecall
	setreadonly(gt, false)
	gt.__namecall = newcclosure(function(self, ...)
		local check = getnamecallmethod()
		local s = getcallingscript()
		if check == "FireServer" and self.Name == "ShootEvent" then
			local args = {...}
			for index = 1, #args[1] do
				local hit = args[1][index]["Hit"]
				if isSafe(hit, ge().PLCdata.nohit) or (#innocents > 0 and isSafe(hit, innocents)) then
					args[1][index]["Hit"] = nil
				end
			end

			if ge().PLCdata.dmgmul > 1 then
				local new = {}
				for _, bullet in pairs(args[1]) do
					for _ = 1, ge().PLCdata.dmgmul do
						table.insert(new, bullet)
					end
				end
				args[1] = new
			end
			return last(self, unpack(args))
		end
		return last(self, ...)
	end)
end

if isPL then
	prisonnotify = require(game:GetService("ReplicatedStorage").Modules_client.TooltipModule).update
end

-- I'll comment on these if you're curious

-- This binds a function to the name (<string>name, <function>, <RBXscriptconnection>bindto?)

local function BindRender(name, func, con)
	con = con or RS.RenderStepped
	table.insert(ge().PLCdata.RenderConnections, {["Name"] = name, ["Connection"] = con:Connect(func)})
end

-- This unbinds the function(s) that have the name (<string>name)

local function UnbindRender(name)
	for i, connection in pairs(ge().PLCdata.RenderConnections) do
		if connection.Name == name then
			connection.Connection:Disconnect()
			table.remove(ge().PLCdata.RenderConnections, i)
		end
	end
end

-- This unbinds and rebinds the function(s) that habe the name (<string>name)

local function RebindRender(name, func, con)
	UnbindRender(name)
	BindRender(name, func, con)
end

-- This finds functions connected to the name and returns how many (<string>name) RETURN: (<bool>isconnected, <int>amount)
local function IsRender(name)
	local counted = 0
	for i, connection in pairs(ge().PLCdata.RenderConnections) do
		if connection.Name == name then
			counted = counted + 1
		end
	end
	return counted > 0, counted
end

local http = game:GetService("HttpService")
local fileName = "PLCsave.txt"
local structure = {
	["Loadouts"] = {},
	["Gunmods"] = {},
	["Admins"] = {},
}

local function JSONload()
	return http:JSONDecode(readfile(fileName))
end

local function JSONsave(t)
	writefile(fileName, http:JSONEncode(t))
end

local function formatFile()
	if isfile(fileName) then
		local data = JSONload()
		for i, v in pairs(structure) do
			if not data[i] or type(data[i]) ~= type(v) then
				data[i] = v
			end
		end
		JSONsave(data)
	else
		JSONsave(structure)
	end
end

formatFile()

local void = CFrame.new(999999, workspace.FallenPartsDestroyHeight + 6, 999999)

if ge().PLCdataunload then
	ge().PLCdataunload()
end

ge().PLCdataunload = function()
	autore = false

	anticrim = false
	if anticrimcon then
		anticrimcon:Disconnect()
	end

	antibring = false
	if antibringcon then
		antibringcon:Disconnect()
	end

	ka = false
	if kacon then
		kacon:Disconnect()
	end

	if loopkillcon then
		loopkillcon:Disconnect()
	end

	loudsound = false

	active = false

	warn("The previous PLC was unloaded, turning off all toggles")
end

local crashing = false
local spamming = false

PLC = {
	["PluginName"] = "Prison admin",
	["PluginDescription"] = "Commands for prison life, by McTurtles5 (github)",
	["Commands"] = {
		["pfastkill"] = {
			["ListName"] = "k [plr]",
			["Description"] = "Kills a player with gun", --"(4 SEC COOLDOWN)" not anymore :)
			["Aliases"] = {"pfk"},
			["Function"] = function(args, speaker)
				GunKill(getPlayer(args[1], speaker))
			end,
		},
		["ploopkill"] = {
			["ListName"] = "loopkill [plr]",
			["Description"] = "Loop kills a player with gun",
			["Aliases"] = {"plk"},
			["Function"] = function(args, speaker)
				local targets = getPlayer(args[1], speaker)
				for _, v in pairs(targets) do
					local target = Players[v]
					local name = "LOOP_KILL_"..target.Name
					local processing = nil
					local time = os.clock() + 1
					local current = Players.LocalPlayer.Character
					RebindRender(name, function()
						if current ~= Players.LocalPlayer.Character then
							time = os.clock() + 0.05
							current = Players.LocalPlayer.Character
						end
						if not Players:FindFirstChild(v) then
							UnbindRender(name)
						end
						if target.Character and (processing ~= target.Character or time < os.clock()) then
							if IsAlive(target) and IsVulnerable(target) then
								table.insert(ge().PLCdata.loopkillprocess, target.Name)
								processing = target.Character
								time = os.clock() + 0.8
							end
						end
					end)
				end
			end,
		},
		["punloopkill"] = {
			["ListName"] = "unloopkill [plr]",
			["Description"] = "Unloop kills a player",
			["Aliases"] = {"punlk"},
			["Function"] = function(args, speaker)
				local targets = getPlayer(args[1], speaker)
				for _, v in pairs(targets) do
					local name = "LOOP_KILL_"..v
					UnbindRender(name)
				end
			end,
		},
		["pkill"] = {
			["ListName"] = "tk [plr]",
			["Description"] = "Teleports to a player and back to kill them",
			["Aliases"] = {"pk"},
			["Function"] = function(args, speaker)
				local targets = getPlayer(args[1], speaker)
				local Char = Players.LocalPlayer.Character
				local Pos = Char:GetPrimaryPartCFrame()
				for _, v in ipairs(targets) do
					local target = game:GetService("Players")[v]
					local attempts = 0
					if target ~= Players.LocalPlayer and IsAlive(target) and IsVulnerable(target) and target then
						local attempts = 0
						repeat wait()
							Goto(target, Char)
							Kill(target)
							attempts = attempts + 1
							if attempts > 40 then
								notify("Error", "Couldent kill "..v)
								break
							end
						until not IsAlive(target)
					end
				end
				Char:SetPrimaryPartCFrame(Pos)
			end,
		},
		["pteamcolor"] = {
			["ListName"] = "pteamcolor / tc [brickcolor]",
			["Description"] = "Change your team color",
			["Aliases"] = {"pteamc", "ptc"},
			["Function"] = function(args, speaker)
				TeamColor(Players.LocalPlayer, args)
			end,
		},
		["pteam"] = {
			["ListName"] = "pteam / t [team]",
			["Description"] = "Changes your team",
			["Aliases"] = {"pteam", "pt"},
			["Function"] = function(args, speaker)
				local input = table.concat(args, " ")
				Team(input, Players.LocalPlayer)
			end,
		},
		["pcrash"] = {
			["ListName"] = "crash [message?]",
			["Description"] = "Crashes everyone else (but can break ur connection. if yes rejoin)",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local message = table.concat(args, " ")
				local RStorage = game:GetService("ReplicatedStorage")
				local SendCrash = RStorage:WaitForChild("ShootEvent")
				local Refill = RStorage:WaitForChild("RefillEvent")
				local packetamount = 40000
				local packetsend = 30
				local bulletlength = math.huge  
				local Tool = "AK-47"

				local function getCrashTool()
					local Player = Players.LocalPlayer
					local choice = Player.Character:FindFirstChild(Tool) or Player:WaitForChild("Backpack"):FindFirstChild("Tool")
					if not choice then
						workspace.Remote.ItemHandler:InvokeServer(workspace.Prison_ITEMS.giver[Tool].ITEMPICKUP)
						choice = Player:WaitForChild("Backpack"):WaitForChild(Tool)
					end
					return choice
				end

				local function crash()
					crashing = true
					notify("Crash", "Creating crash table")

					wait(1)
					local CrashTable = {}
					for i=1, packetamount do 
						CrashTable[i] = {
							Cframe = CFrame.new(),
							Distance = bulletlength
						}
					end

					if message ~= "" then
						Chat(message)
					end

					notify("Crash", "Sending crash packets... (don't use ak-47)")

					for i=1, packetsend do
						if not crashing then
							break
						end
						coroutine.resume(coroutine.create(function()
							SendCrash:FireServer(CrashTable, getCrashTool())
						end))
						print("Sending packets "..i.."/"..packetsend.." ("..math.floor((i / packetsend) * 100).."%)")
						wait(0.3)
					end
					if crashing then
						notify("Crash", "Crash complete!")
					else
						notify("Crash", "Crash canceled")
					end
					crashing = false
				end
				crash()
			end,
		},
		["cancelcrash"] = {
			["ListName"] = "cancelcrash / stopcrash",
			["Description"] = "Cancels the crash process",
			["Aliases"] = {"stopcrash"},
			["Function"] = function(args, speaker)
				crashing = false
			end,
		},
		["pgetgun"] = {
			["ListName"] = "getgun / gun / item / get [item]",
			["Description"] = "Gives you a prison item",
			["Aliases"] = {"pgun", "pequip", "pg"},
			["Function"] = function(args, speaker)
				local remote = workspace.Remote.ItemHandler
				local folder = workspace.Prison_ITEMS
				local input = table.concat(args, " ")
				local items = {}
				if input:lower() == "all" then
					items = possibleItems
				else
					for _, found in pairs(possibleItems) do
						if string.sub(found:lower(), 1, input:len()) == input:lower() then
							table.insert(items, #items+1, found)
						end
					end
				end
				for _, item in pairs(items) do
					local succsses = false
					for _, sec in pairs(folder:GetChildren()) do
						local found = sec:FindFirstChild(item)
						if found then
							local pickup = found:FindFirstChild("ITEMPICKUP")
							if pickup then
								coroutine.resume(coroutine.create(function()
									remote:InvokeServer(pickup)
								end))
								succsses = true
								break
							else
								notify("Cant pick up", "Couldent pick up "..item)
								succsses = true
								break
							end
						end
					end
					if not succsses then
						notify("Cant find", "Couldent find "..item)
					end
				end
			end,
		},
		["prespawn"] = {
			["ListName"] = "prespawn / pre",
			["Description"] = "Respawns you where you are with remotes",
			["Aliases"] = {"pre"},
			["Function"] = function(args, speaker)
				Respawn()
			end,
		},
		["phardrespawn"] = {
			["ListName"] = "hardrespawn / hre",
			["Description"] = "Respawns you but its just the remote",
			["Aliases"] = {"phre"},
			["Function"] = function(args, speaker)
				workspace.Remote.loadchar:InvokeServer()
			end,
		},
		["pauto"] = {
			["ListName"] = "auto / autore / autorespawn [on/off]",
			["Description"] = "Respawns you with remotes when you die",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local arg = args[1]:lower()
				if arg == "on" then
					autore = true
					notify("Enabled", "Autorespawn was turned on")
				elseif arg == "off" then
					autore = false
					notify("Disabled", "Autorespawn was turned off")
				else
					notify("Invalid", "Invalid argument. Do 'on/off'")
				end
			end,
		},
		["pka"] = {
			["ListName"] = "ka [on/off]",
			["Description"] = "Rapidly damages everyone near you",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local arg = args[1]:lower()
				if arg == "on" then
					Killaura(speaker)
					ka = true
					notify("Enabled", "Killaura was turned on")
				elseif arg == "off" then
					if kacon then
						kacon:Disconnect()
					end
					ka = false
					notify("Disabled", "Killaura was turned off")
				else
					notify("Invalid", "Invalid argument. Do 'on/off'")
				end
			end,
		},
		["pfastpunch"] = {
			["ListName"] = "fastpunch / superpunch / fp [multiplier]",
			["Description"] = "Makes your punch kinda op (each punch is 11 dmg) (14 is instant)]",
			["Aliases"] = {"psuperpunch", "pfp"},
			["Function"] = function(args, speaker)
				local mul = tonumber(args[1]) or 1
				local mainRemotes = game.ReplicatedStorage
				local meleeRemote = mainRemotes['meleeEvent']
				local mouse = game.Players.LocalPlayer:GetMouse()
				local enabled = true
				local rightpunch = true
				local right = Players.LocalPlayer.Character.ClientInputHandler.fight_right
				local left = Players.LocalPlayer.Character.ClientInputHandler.fight_left
				local function Sound(snd)
					local snd2 = snd:Clone()
					snd2:Play()
					snd2.TimePosition = 0
					snd2.Parent = snd.Parent
					game:GetService("Debris"):AddItem(snd2, snd2.TimeLength + 1)
					local args = {
						[1] = snd,
						[2] = snd.Parent,
					}
					game:GetService("ReplicatedStorage").SoundEvent:FireServer(unpack(args))
				end
				local function punch()
					local part = Instance.new("Part", Players.LocalPlayer.Character)
					part.Transparency = 1
					part.Size = Vector3.new(5, 2, 3)
					part.CanCollide = false
					local w1 = Instance.new("Weld", part)
					w1.Part0 = game.Players.LocalPlayer.Character.Torso
					w1.Part1 = part
					w1.C1 = CFrame.new(0, 0, 2)
					part.Touched:connect(function(hit)
						if not hit:IsDescendantOf(Players.LocalPlayer.Character) then
							local plr = Players:GetPlayerFromCharacter(hit.Parent)
							if plr then
								part:Destroy()
								for i = 1, mul do
									meleeRemote:FireServer(plr)
									Sound(Players.LocalPlayer.Character.Head.punchSound)
								end
							end
						end
					end)
					wait()
					if rightpunch then
						Players.LocalPlayer.Character.Humanoid:LoadAnimation(right):Play()
					else
						Players.LocalPlayer.Character.Humanoid:LoadAnimation(left):Play()
					end
					rightpunch = not rightpunch
					part:Destroy()
				end
				local mousecon = mouse.KeyDown:connect(function(key)
					if enabled and key:lower() == "f" then
						coroutine.resume(coroutine.create(punch))
					end
				end)
				Players.LocalPlayer.CharacterAdded:Wait()
				mousecon:Disconnect()
				enabled = false
			end,
		},
		["psuperfastpunch"] = {
			["ListName"] = "superfastpunch / fastsuperpunch / sfp [multiplier]",
			["Description"] = "Makes your punch super fast [Multiplier] (each punch is 11 dmg) (14 is instant)]",
			["Aliases"] = {"pfastsuperpunch", "psfp"},
			["Function"] = function(args, speaker)
				local mul = tonumber(args[1]) or 1
				local enabled = true
				local mainRemotes = game.ReplicatedStorage
				local meleeRemote = mainRemotes['meleeEvent']
				local mouse = game.Players.LocalPlayer:GetMouse()
				local rightpunch = true
				local right = Players.LocalPlayer.Character.ClientInputHandler.fight_right
				local left = Players.LocalPlayer.Character.ClientInputHandler.fight_left
				local function Sound(snd)
					local snd2 = snd:Clone()
					snd2:Play()
					snd2.TimePosition = 0
					snd2.Parent = snd.Parent
					game:GetService("Debris"):AddItem(snd2, snd2.TimeLength + 1)
					local args = {
						[1] = snd,
						[2] = snd.Parent,
					}
					game:GetService("ReplicatedStorage").SoundEvent:FireServer(unpack(args))
				end
				local function punch()
					local part = Instance.new("Part", Players.LocalPlayer.Character)
					part.Transparency = 1
					part.Size = Vector3.new(5, 2, 3)
					part.CanCollide = false
					local w1 = Instance.new("Weld", part)
					w1.Part0 = game.Players.LocalPlayer.Character.Torso
					w1.Part1 = part
					w1.C1 = CFrame.new(0, 0, 2)
					part.Touched:connect(function(hit)
						if not hit:IsDescendantOf(Players.LocalPlayer.Character) then
							local plr = Players:GetPlayerFromCharacter(hit.Parent)
							if plr then
								part:Destroy()
								for i = 1, mul do
									meleeRemote:FireServer(plr)
									Sound(Players.LocalPlayer.Character.Head.punchSound)
								end
							end
						end
					end)
					wait()
					if rightpunch then
						Players.LocalPlayer.Character.Humanoid:LoadAnimation(right):Play(0, 1, 60)
					else
						Players.LocalPlayer.Character.Humanoid:LoadAnimation(left):Play(0, 1, 60)
					end
					rightpunch = not rightpunch
					part:Destroy()
				end
				local con = mouse.KeyDown:connect(function(key)
					if enabled and key:lower() == "f" then
						RS:BindToRenderStep("FastPunch", 1, punch)
					end
				end)
				mouse.KeyUp:connect(function(key)
					if key:lower() == "f" then
						RS:UnbindFromRenderStep("FastPunch")
					end
				end)
				Players.LocalPlayer.CharacterAdded:Wait()
				con:Disconnect()
				enabled = false
			end,
		},
		["parmorgod"] = {
			["ListName"] = "armorgod / agod",
			["Description"] = "Makes you hard to kill by spamming armor when hurt (MUST HAVE SWAT AND BE A GUARD)",
			["Aliases"] = {"pgod"},
			["Function"] = function(args, speaker)
				local arg = workspace.Prison_ITEMS.clothes["Riot Police"].ITEMPICKUP
				local Humanoid = Players.LocalPlayer.Character.Humanoid
				local HP = Humanoid.Health
				Humanoid.HealthChanged:Connect(function(CURHP)
					if CURHP < HP then
						coroutine.resume(coroutine.create(function()
							workspace.Remote.ItemHandler:InvokeServer(arg)
						end))
					end
					HP = Humanoid.Health
				end)
			end,
		},
		["pcriminal"] = {
			["ListName"] = "crim [plr]",
			["Description"] = "Teleports a player to the criminal spawns to make them a criminal",
			["Aliases"] = {"pcrim"},
			["Function"] = function(args, speaker)
				local players = getPlayer(args[1], speaker)
				for _, v in pairs(players) do
					prisonteleport(Players.LocalPlayer, Players[v], workspace["Criminals Spawn"].SpawnLocation.CFrame)
				end
			end,
		},
		["parrest"] = {
			["ListName"] = "arrest / ar [plr] [multiplier]",
			["Description"] = "Teleports to a player and back to arrest them",
			["Aliases"] = {"par"},
			["Function"] = function(args, speaker)
				local targets = getPlayer(args[1], speaker)
				local mul = tonumber(args[2])
				if not mul then
					mul = 1
				end
				local Char = Players.LocalPlayer.Character
				local Pos = Char:GetPrimaryPartCFrame()
				local function Goto(plr)
					Char.Humanoid.Sit = false
					local root = getRoot(plr.Character) or plr.Character:FindFirstChildOfClass("BasePart")
					local frame = root.CFrame
					frame = frame * CFrame.new(0, 5, -2)
					Char.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
					Char:SetPrimaryPartCFrame(frame)
				end
				local function arrest(plr)
					local i = getRoot(plr.Character) or plr.Character:FindFirstChildOfClass("BasePart")
					if i then
						coroutine.resume(coroutine.create(function()
							workspace.Remote.arrest:InvokeServer(i)
						end))
					end
				end
				for _, v in ipairs(targets) do
					local target = Players[v]
					local attempts = 0
					if target then
						local con = RS.RenderStepped:Connect(function()
							Goto(target)
						end)
						wait(0.3)
						for i = 1, mul do
							arrest(target)
						end
						wait(0.1)
						con:Disconnect()
					end
				end
				Char:SetPrimaryPartCFrame(Pos)
			end,
		},
		["pbring"] = {
			["ListName"] = "pbring [plr]",
			["Description"] = "Brings a player to you",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local players = getPlayer(args[1], speaker)
				local root = getRoot(Players.LocalPlayer.Character) or Players.LocalPlayer.Character:FindFirstChildOfClass("BasePart")
				if not root then return end
				local bringpos = root.CFrame
				for _, v in pairs(players) do
					prisonteleport(Players.LocalPlayer, game:GetService("Players")[v], bringpos)
				end
			end,
		},
		["pteleport"] = {
			["ListName"] = "pteleport [plr] [plr2]",
			["Description"] = "Teleports a player to a player [plr] [plr2]",
			["Aliases"] = {"ptp"},
			["Function"] = function(args, speaker)
				local targets = getPlayer(args[1], speaker)
				local bringpos = void
				local argstring = tostring(args[2])
				if argstring and argstring:lower() ~= "void" then
					local name = getPlayer(args[2], speaker)[1]
					local target = Players[name]
					local root = getRoot(target.Character) or target.Character:FindFirstChildOfClass("BasePart")
					if not root then return end
					bringpos = root.CFrame
				end
				for _, v in pairs(targets) do
					prisonteleport(Players.LocalPlayer, Players[v], bringpos)
				end
			end,
		},
		["pattach"] = {
			["ListName"] = "pattach [plr]",
			["Description"] = "Attaches you to a player to control them for "..Players.RespawnTime.."s [plr]",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local players = getPlayer(args[1], speaker)
				local root = getRoot(Players.LocalPlayer.Character) or Players.LocalPlayer.Character:FindFirstChildOfClass("BasePart")
				if not root then return end
				local bringpos = root.CFrame
				for _, v in pairs(players) do
					local target = Players[v]
					local arg = workspace.Prison_ITEMS.giver:FindFirstChild("Remington 870").ITEMPICKUP
					if target ~= nil and IsAlive(target) then
						local NormPos = getRoot(Players.LocalPlayer.Character).CFrame
						if not ge().PLCdata.fastbring then
							workspace.Remote.loadchar:InvokeServer()
						end
						workspace.Remote.ItemHandler:InvokeServer(arg)
						local current = Players.LocalPlayer.Character
						local tool = current:FindFirstChildOfClass("Tool") or Players.LocalPlayer.Backpack:FindFirstChildOfClass("Tool")
						tool.Parent = Players.LocalPlayer.Backpack
						repeat wait() until Players.LocalPlayer.Character ~= nil and getRoot(Players.LocalPlayer.Character)
						local hrp = getRoot(Players.LocalPlayer.Character)
						attach(Players.LocalPlayer, target)
						tool.Parent = hrp.Parent
						hrp.Parent:FindFirstChildOfClass("Humanoid"):ChangeState(2)
						repeat RS.RenderStepped:Wait()
						until not getRoot(target.Character) or not current or not current.Parent
						Respawn(NormPos)
					else
						notify("Error", "Target is nil/dead")
					end
				end
			end,
		},
		["pgive"] = {
			["ListName"] = "give [plr] [item]",
			["Description"] = "Gives a player your selected item, or the name of the item or 1st one if none are selected",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local players = getPlayer(args[1], speaker)
				local root = getRoot(Players.LocalPlayer.Character) or Players.LocalPlayer.Character:FindFirstChildOfClass("BasePart")
				if not root then return end
				local bringpos = root.CFrame
				for _, v in pairs(players) do
					local target = Players[v]
					if target ~= nil and IsAlive(target) then
						local NormPos = getRoot(Players.LocalPlayer.Character).CFrame
						local current = Players.LocalPlayer.Character
						local tool = Players.LocalPlayer.Character:FindFirstChildOfClass("Tool") or Players.LocalPlayer.Backpack:FindFirstChildOfClass("Tool")
						if args[2] then
							local foundtool = Players.LocalPlayer.Backpack:FindFirstChild(args[2])
							if foundtool then
								tool = foundtool
							end
						end
						tool.Parent = Players.LocalPlayer.Backpack
						local hrp = getRoot(Players.LocalPlayer.Character)
						local targetpos = getRoot(target.Character).CFrame
						attach(Players.LocalPlayer, target, tool)
						--RS.RenderStepped:Wait()
						Respawn(NormPos)
					else
						notify("Error", "Target is nil/dead")
					end
				end
			end,
		},
		["pantilag"] = {
			["ListName"] = "pantilag",
			["Description"] = "Runs anti lag, effective for armor spam and arrest spam",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local Quered = {}
				function clear()
					for _, part in pairs(Quered) do
						if part then
							part:Destroy()
						end
					end
					table.clear(Quered)
				end
				RS.RenderStepped:Connect(clear)
				RS.Stepped:Connect(clear)
				local function Remove(part)
					table.insert(Quered, part)
				end
				local function Begin(Player)
					local Char = Player.Character
					local Head = Char:WaitForChild("Head", 3)
					Char.ChildAdded:Connect(function(v)
						if v.Name == "vest" then
							Remove(v)
						end
					end)
					Head.ChildAdded:Connect(function(v)
						if v.Name == "handcuffedGui" then
							v.Enabled = false
							Remove(v)
						end
					end)
				end
				for _, Player in pairs(Players:GetPlayers()) do
					Begin(Player)
					Player.CharacterAdded:Connect(function()
						Begin(Player)
					end)
				end
				Players.PlayerAdded:Connect(function(Player)
					Player.CharacterAdded:Connect(function()
						Begin(Player)
					end)
				end)
				notify("Anti lag", "Anti lag was enabled until you rejoin")
			end,
		},
		["pdeletshield"] = {
			["ListName"] = "deletshield / noshield",
			["Description"] = "Removes shields from everyone else",
			["Aliases"] = {"pnoshield"},
			["Function"] = function(args, speaker)
				for _, player in pairs(game:GetService("Players"):GetPlayers()) do
					if player ~= game:GetService("Players").LocalPlayer then
						local char = player.Character
						if char then
							local torso = char:FindFirstChild("Torso")
							if torso then
								local shieldfolder = torso:FindFirstChild("ShieldFolder")
								if shieldfolder then
									shieldfolder:Destroy()
								end
							end
						end
					end
				end
			end,
		},
		["pgetcolor"] = {
			["ListName"] = "getcolor [plr]",
			["Description"] = "Notifies a players team color",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local plrs = getPlayer(args[1], speaker)
				local s = {}
				for _, v in pairs(plrs) do
					local plr = game:GetService("Players")[v]
					local color = tostring(plr.TeamColor)
					local info = ""
					for _, i in pairs(possibleTeams) do
						if i[2] == color then
							info = " ("..i[1]..")"
						end
					end
					table.insert(s, v.."'s color is: "..color..info)
				end
				notify("Player color"..(#plrs > 1 and "s" or ""), table.concat(s, "\n"))
			end,
		},
		["pfastcar"] = {
			["ListName"] = "fastcar / fsc [speed] [turnspeed] [strength]",
			["Description"] = "Makes your cars fast",
			["Aliases"] = {"fsc"},
			["Function"] = function(args, speaker)
				local speed = tonumber(args[1]) or 500
				local turnspeed = tonumber(args[2])or 2
				local strength = tonumber(args[3]) or 40000

				local Char = Players.LocalPlayer.Character
				local hum = Char:FindFirstChildOfClass("Humanoid")
				local root = hum.RootPart
				local vel = Instance.new("BodyVelocity", root)
				local turn = Instance.new("BodyAngularVelocity", root)
				local gyro = Instance.new("BodyGyro", root)
				local enabled = true
				turn.AngularVelocity = Vector3.new(0, 0, 0)
				Players.LocalPlayer.CharacterAdded:Connect(function()enabled=false;end)
				hum.Died:Connect(function()enabled=false;end)
				repeat wait()
					local seat = hum.SeatPart
					if seat then
						if seat:IsA("VehicleSeat") then
							local active = true
							vel.MaxForce = Vector3.new(strength, 0, strength)
							turn.MaxTorque = Vector3.new(0, "inf", 0)
							gyro.MaxTorque = Vector3.new(0, 0, 100)
							repeat RS.RenderStepped:Wait()
								if hum.SeatPart~=seat then
									active = false
								end
								vel.Velocity = root.CFrame.LookVector * (speed * seat.Throttle)
								turn.AngularVelocity = Vector3.new(0, -(turnspeed * seat.Steer), 0)
							until not active or not enabled
						end
					else
						vel.MaxForce = Vector3.new(0, 0, 0)
						turn.MaxTorque = Vector3.new(0, 0, 0)
						gyro.MaxTorque = Vector3.new(0, 0, 0)
					end
				until not enabled
			end,
		},
		["pdamage"] = {
			["ListName"] = "damage",
			["Description"] = "Makes you take 35 damage to trick guards i guess",
			["Aliases"] = {"pracecar"},
			["Function"] = function(args, speaker)
				local Root = getRoot(Players.LocalPlayer.Character) or Players.LocalPlayer.Character:FindFirstChildOfClass("BasePart")
				local Part = workspace["Prison_Fences"].fence.damagePart
				firetouchinterest(Part, Root, 1, wait() and firetouchinterest(Part, Root, 0))
			end,
		},
		["p18+"] = {
			["ListName"] = "18+ / [REDACTED] / [REDACTED]",
			["Description"] = "wh- why just why (MUST NOT BE A GUARD) (its 18+)",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local Tool = Players.LocalPlayer.Backpack:FindFirstChild("Hammer") or Players.LocalPlayer.Character:FindFirstChild("Hammer")
				if not Tool then
					local arg = workspace.Prison_ITEMS.single:FindFirstChild("Hammer").ITEMPICKUP
					workspace.Remote.ItemHandler:InvokeServer(arg)
					Tool = Players.LocalPlayer.Backpack:FindFirstChild("Hammer")
				end
				Tool.Grip = CFrame.new(1.5, 0.9, 1.6) * CFrame.Angles(math.rad(-90), 0, math.rad(-90))
				Tool.ToolTip = "sus hammer 😳"
			end,
		},
		["ploadout"] = {
			["ListName"] = "loadout [loadout name]",
			["Description"] = "Gives you your custom loadout",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local remote = workspace.Remote.ItemHandler
				local folder = workspace.Prison_ITEMS
				local Holders = {}
				local name = string.lower(table.concat(args, " "))
				if name == "" then name = ge().PLCdata.lastloadout end
				formatFile()
				local data = JSONload()
				local found = data["Loadouts"][name]
				if not found then
					notify("Invalid", "Please enter a valid loadout name")
					return
				end
				local current = Players.LocalPlayer.Character
				for _, item in ipairs(found) do
					if current ~= Players.LocalPlayer.Character then
						break
					end
					local sucsses = false
					if item == "" then
						table.insert(Holders, #Holders+1, getPlaceHolder())
						sucsses = true
					else
						for _, sec in pairs(folder:GetChildren()) do
							local found = sec:FindFirstChild(item)
							if found then
								local pickup = found:FindFirstChild("ITEMPICKUP")
								if pickup then
									remote:InvokeServer(pickup)
									if HasItem(item, Players.LocalPlayer) then
										sucsses = true
									end
									break
								else
									table.insert(Holders, getPlaceHolder())
									sucsses = true
									break
								end
							end
						end
						--wait(0.1)
					end
					if not sucsses then
						table.insert(Holders, getPlaceHolder())
					end
				end
				for _, v in pairs(Holders) do
					game:GetService("Debris"):AddItem(v, 0.1)
				end
				ge().PLCdata.lastloadout = name
			end,
		},
		["psaveloadout"] = {
			["ListName"] = "saveloadout [loadout name]",
			["Description"] = "Saves your current inventory to a custom loadout",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local core = game:GetService("CoreGui"):FindFirstChild("RobloxGui")
				local loadname = table.concat(args, " ")
				if loadname == "" then loadname = ge().PLCdata.lastloadout end
				if core then
					if not loadname then
						notify("Invalid", "Please enter a loadout name")
						return
					end
					loadname = loadname:lower()
					local list = {}
					for i, item in pairs(core.Backpack.Hotbar:GetChildren()) do
						local name = item.ToolName.Text
						if name then
							list[i] = name
						else
							list[i] = 0
						end
					end
					formatFile()
					local data = JSONload()
					data.Loadouts[loadname] = list
					JSONsave(data)
					notify("Saved", "Saved your inventory to "..loadname)
					ge().PLCdata.lastloadout = loadname
				else
					notify("No gui", "Coulden't find the roblox gui and loadout did not save")
				end
			end,
		},
		["pdeletloadout"] = {
			["ListName"] = "deletloadout [loadout name]",
			["Description"] = "Delets this custon loadout [name]",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local loadname = table.concat(args, " ")
				if loadname == "" then loadname = ge().PLCdata.lastloadout end
				if not loadname then
					notify("Invalid", "Please enter a loadout name")
					return
				end
				loadname = loadname:lower()
				formatFile()
				local data = JSONload()
				data.Loadouts[loadname] = nil
				JSONsave(data)
				notify("Removed", "Removed the loadout "..loadname)
				ge().PLCdata.lastloadout = loadname
			end,
		},
		["ploadgunmod"] = {
			["ListName"] = "loadgunmod / loadmod [gunmod name]",
			["Description"] = "Gives you your gun mod",
			["Aliases"] = {"ploadmod"},
			["Function"] = function(args, speaker)
				local name = string.lower(table.concat(args, " "))
				if name == "" then name = ge().PLCdata.lastgunmod end
				formatFile()
				local data = JSONload()
				local found = data["Gunmods"][name]
				if not found then
					notify("Invalid", "Please enter a valid gunmod name")
					return
				end
				local current = Players.LocalPlayer.Character
				local function modify(gun)
					local mod = gun:FindFirstChildOfClass("ModuleScript")
					if mod then
						local sM = require(mod)
						if found["Firerate"] ~= "N" then
							savemod(gun, "Firerate", found["Firerate"])
							sM["FireRate"] = found["Firerate"]
						end
						if found["BulletAmount"] ~= "N" then
							savemod(gun, "BulletAmount", found["BulletAmount"])
							sM["Bullets"] = found["BulletAmount"]
						end
						if found["Spread"] ~= "N" then
							savemod(gun, "Spread", found["Spread"])
							sM["Spread"] = found["Spread"]
						end
						if found["Range"] ~= "N" then
							savemod(gun, "Range", found["Range"])
							sM["Range"] = found["Range"]
						end
						if found["Auto"] ~= "N" then
							savemod(gun, "Auto", found["Auto"])
							sM["AutoFire"] = found["Auto"]
						end
						if found["NoReloadtime"] then
							savemod(gun, "NoReloadtime", true)
							sM["ReloadTime"] = 0
						end
						local interface = gun.GunInterface
						gun.Parent = Players.LocalPlayer.Backpack
						interface.Disabled = true
						RS.Heartbeat:Wait()
						interface.Disabled = false
					end
				end
				local gun = Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
				if gun then
					modify(gun)
				else
					for _, v in pairs(Players.LocalPlayer.Backpack:GetChildren()) do
						modify(v)
					end
				end
				ge().PLCdata.lastgunmod = name
			end,
		},
		["pgunwithgunmod"] = {
			["ListName"] = "gunwithgunmod / loadgunwithmod / gunwmod [gun name] [gunmod name]",
			["Description"] = "Gives you a gun with the gun mod applied",
			["Aliases"] = {"ploadgunwithgunmod", "pgunwmod"},
			["Function"] = function(args, speaker)
				local name = string.lower(table.concat(args, " ", 2))
				if name == "" then name = ge().PLCdata.lastgunmod end
				formatFile()
				local data = JSONload()
				local found = data["Gunmods"][name]
				if not found then
					notify("Invalid", "Please enter a valid gunmod name")
					return
				end
				local input = args[1]
				local item = nil
				for _, f in pairs(possibleItems) do
					if string.sub(f:lower(), 1, input:len()) == input:lower() then
						item = f
					end
				end
				local succsses = false
				local remote = workspace.Remote.ItemHandler
				local folder = workspace.Prison_ITEMS
				for _, sec in pairs(folder:GetChildren()) do
					local found = sec:FindFirstChild(item)
					if found then
						local pickup = found:FindFirstChild("ITEMPICKUP")
						if pickup then
							remote:InvokeServer(pickup)
							succsses = true
							break
						else
							notify("Cant pick up", "Couldent pick up "..item)
							succsses = true
							break
						end
					end
				end
				if not succsses then
					notify("Cant find", "Couldent find "..item)
					return
				end
				local current = Players.LocalPlayer.Character
				local gun = Players.LocalPlayer.Backpack:FindFirstChild(item)
				local mod = gun:FindFirstChild("GunStates")
				if mod then
					local sM = require(mod)
					if found["Firerate"] ~= "N" then
						savemod(gun, "Firerate", found["Firerate"])
						sM["FireRate"] = found["Firerate"]
					end
					if found["BulletAmount"] ~= "N" then
						savemod(gun, "BulletAmount", found["BulletAmount"])
						sM["Bullets"] = found["BulletAmount"]
					end
					if found["Spread"] ~= "N" then
						savemod(gun, "Spread", found["Spread"])
						sM["Spread"] = found["Spread"]
					end
					if found["Range"] ~= "N" then
						savemod(gun, "Range", found["Range"])
						sM["Range"] = found["Range"]
					end
					if found["Auto"] ~= "N" then
						savemod(gun, "Auto", found["Auto"])
						sM["AutoFire"] = found["Auto"]
					end
					if found["NoReloadtime"] then
						savemod(gun, "NoReloadtime", found["NoReloadtime"])
						sM["ReloadTime"] = found["NoReloadtime"]
					end
					local interface = gun.GunInterface
					gun.Parent = Players.LocalPlayer.Backpack
					interface.Disabled = true
					RS.Heartbeat:Wait()
					interface.Disabled = false
				end
				ge().PLCdata.lastgunmod = name
			end,
		},
		["psavegunmod"] = {
			["ListName"] = "savegunmod [gunmod name]",
			["Description"] = "Save this custom gun mod (HOLD GUN) [name]",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local name = table.concat(args, " ")
				if name == "" then name = ge().PLCdata.lastgunmod end
				if not name then
					notify("Invalid", "Please enter a gunmod name")
					return
				end
				local current = Players.LocalPlayer.Character
				local gun = current:FindFirstChildOfClass("Tool")
				if not gun then
					notify("Invalid", "Please hold out your gun")
					return
				end
				local sM = gun:FindFirstChild("GunStates")
				if sM then
					name = name:lower()
					formatFile()
					local data = JSONload()
					local t = require(sM)["PLCModifications"]
					data.Gunmods[name] = t
					JSONsave(data)
					notify("Saved", "Saved your gunmod to "..name)
					ge().PLCdata.lastgunmod = name
				else
					notify("Invalid", "This gun doesn't have modifications. Or it's not a gun")
				end
			end,
		},
		["pdeletgunmod"] = {
			["ListName"] = "deletgunmod [gunmod name]",
			["Description"] = "Delets this custom gun mod [name]",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local name = table.concat(args, " ")
				if name == "" then name = ge().PLCdata.lastgunmod end
				if not name then
					notify("Invalid", "Please enter a gunmod name")
					return
				end
				name = name:lower()
				formatFile()
				local data = JSONload()
				data.Gunmods[name] = nil
				JSONsave(data)
				notify("Removed", "Removed the gunmod "..name)
				ge().PLCdata.lastgunmod = name
			end,
		},
		["pfixfade"] = {
			["ListName"] = "fixfade",
			["Description"] = "Fixes the fadeing screen and makes it transparent",
			["Aliases"] = {"prestorefade"},
			["Function"] = function(args, speaker)
				local home = Players.LocalPlayer.PlayerGui:FindFirstChild("Home")
				if home then
					local fade = home:FindFirstChild("fadeFrame")
					if fade then
						fade.BackgroundTransparency = 1
					end
				end
			end,
		},
		["ptase"] = {
			["ListName"] = "tase [plr]",
			["Description"] = "Tases somebody",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local Color = tostring(Players.LocalPlayer.TeamColor)
				local waiting = true
				local c = 0
				Team("g")
				repeat
					c = c + 1
					if tostring(Players.LocalPlayer.TeamColor) == "Bright blue" then
						waiting = false
					end
					if c > 240 then
						break
					end 
					RS.Heartbeat:Wait()
				until not waiting
				if not waiting then
					Respawn()
					local Taser = Players.LocalPlayer.Backpack:FindFirstChild("Taser") or Players.LocalPlayer.Character:FindFirstChild("Taser")
					local rargs = {
						[1] = {},
						[2] = Taser
					}	
					for _, plr in pairs(getPlayer(args[1], speaker)) do
						plr = Players[plr]
						local Hit = plr.Character:FindFirstChild("Head")--getRoot(plr.Character) or plr.Character:FindFirstChildOfClass("BasePart")
						local arg = {
							["RayObject"] = Ray.new(Vector3.new(827.41241455078, 101.48977661133, 2296.8432617188), Vector3.new(277.73867797852, 6.8934092521667, 287.7737121582)),
							["Distance"] = 4.7204174995422,
							["Cframe"] = CFrame.new(Vector3.new(832.04937744141, 101.39200592041, 2300.9716796875), Vector3.new(-0.53363537788391, -0.10343056917191, -0.83936601877213)),
							["Hit"] = Hit,
						}
						table.insert(rargs[1], #rargs[1]+1, arg)
					end
					game:GetService("ReplicatedStorage").ShootEvent:FireServer(unpack(rargs))
					wait()
					TeamColor(Players.LocalPlayer, {Color})
				else
					notify("Couldent tase", "Took too long to switch to cops team, or its full")
				end
			end,
		},
		["pmodgun"] = {
			["ListName"] = "modgun [rate] [amount] [auto (y/n)]",
			["Description"] = "Mods your selected gun. Or all if no gun is held",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local rate = tonumber(args[1]) or 0
				local amount = tonumber(args[2]) or 1
				local auto = true
				if args[3] and args[3]:lower() == "n" then
					auto = false
				end
				local function modify(gun)
					local mod = gun:FindFirstChildOfClass("ModuleScript")
					if mod then
						local sM = require(mod)
						sM["FireRate"] = rate
						sM["AutoFire"] = auto
						sM["Bullets"] = amount
					end
					savemod(gun, "Firerate", rate)
					savemod(gun, "Auto", auto)
					savemod(gun, "BulletAmount", amount)
				end
				local gun = Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
				if gun then
					modify(gun)
				else
					for _, v in pairs(Players.LocalPlayer.Backpack:GetChildren()) do
						modify(v)
					end
				end
			end,
		},
		["pspread"] = {
			["ListName"] = "spread [spread]",
			["Description"] = "Changes spread of your selected gun. Or all if no gun is held (greater = less spread)",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local spread = tonumber(args[1]) or 0
				local function modify(gun)
					local mod = gun:FindFirstChildOfClass("ModuleScript")
					if mod then
						local sM = require(mod)
						sM["Spread"] = spread
						local interface = gun.GunInterface
						gun.Parent = Players.LocalPlayer.Backpack
						interface.Disabled = true
						RS.Heartbeat:Wait()
						interface.Disabled = false
						savemod(gun, "Spread", spread)
					end
				end
				local gun = Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
				if gun then
					modify(gun)
				else
					for _, v in pairs(Players.LocalPlayer.Backpack:GetChildren()) do
						modify(v)
					end
				end
			end,
		},
		["prange"] = {
			["ListName"] = "range [range]",
			["Description"] = "Changes range of your selected gun. Or all if no gun is held (defaults to 2480)",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local range = tonumber(args[1]) or 2480
				local function modify(gun)
					local mod = gun:FindFirstChildOfClass("ModuleScript")
					if mod then
						local sM = require(mod)
						sM["Range"] = range
						local interface = gun.GunInterface
						gun.Parent = Players.LocalPlayer.Backpack
						interface.Disabled = true
						RS.Heartbeat:Wait()
						interface.Disabled = false
						savemod(gun, "Range", range)
					end
				end
				local gun = Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
				if gun then
					modify(gun)
				else
					for _, v in pairs(Players.LocalPlayer.Backpack:GetChildren()) do
						modify(v)
					end
				end
			end,
		},
		["pnoreloadtime"] = {
			["ListName"] = "noreloadtime",
			["Description"] = "Mods your selected gun to have fast reload. Or all if no gun is held",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local function modify(gun)
					local mod = gun:FindFirstChildOfClass("ModuleScript")
					if mod then
						local sM = require(mod)
						sM["ReloadTime"] = 0
						savemod(gun, "NoReloadtime", true)
					end
				end
				local gun = Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
				if gun then
					modify(gun)
				else
					for _, v in pairs(Players.LocalPlayer.Backpack:GetChildren()) do
						modify(v)
					end
				end
			end,
		},
		["pinfammo"] = {
			["ListName"] = "infammo",
			["Description"] = "Gives the gun infinite ammo. Or all if no gun is held",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local function reload(gun)
					game:GetService("ReplicatedStorage").ReloadEvent:FireServer(gun)
					local mod = gun:FindFirstChildOfClass("ModuleScript")
					if mod then
						local sM = require(mod)
						sM["CurrentAmmo"] = sM["MaxAmmo"]
					end
				end
				local function modify(gun)
					coroutine.resume(coroutine.create(function()
						while gun and gun.Parent and gun ~= nil and gun.Parent ~= nil do
							RS.RenderStepped:Wait()
							local mod = gun:FindFirstChildOfClass("ModuleScript")
							local sM = require(mod)
							if sM["CurrentAmmo"] <= 0 then
								reload(gun)
							end
						end
					end))
				end
				local gun = Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
				if gun then
					modify(gun)
				else
					for _, v in pairs(Players.LocalPlayer.Backpack:GetChildren()) do
						modify(v)
					end
				end
			end,
		},
		["pswatak"] = {
			["ListName"] = "swatak / fakem4 / fakem4a1 / bootlegm4 / bootlegm4a1",
			["Description"] = "Makes your AK-47 act like a M4A1",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local gun = Players.LocalPlayer.Backpack:FindFirstChild("AK-47") or Players.LocalPlayer.Character:FindFirstChild("AK-47")
				if gun then
					local data = {
						Damage = 11, 
						Description = "Remember to put a description here BEFORE the game is published -Me", 
						MaxAmmo = 30, 
						CurrentAmmo = 30, 
						StoredAmmo = 600, 
						AutoFire = true, 
						Range = 800, 
						Spread = 18,
						FireRate = 0.0875, 
						ReloadTime = 2, 
						Bullets = 1, 
						ReloadAnim = "ReloadMagazine", 
						ShootAnim = "ShootBullet", 
						HoldAnim = "Hold", 
						FireSoundId = "http://www.roblox.com/asset/?id=2934888536", 
						SecondarySoundId = nil, 
						ReloadSoundId = "http://www.roblox.com/asset/?id=2934887229"
					}
					local mod = gun:FindFirstChildOfClass("ModuleScript")
					local sM = require(mod)
					sM["FireRate"] = 0.0875
					sM["FireSoundId"] = "rbxassetid://2934888536"
					gun.Name = "M4A1"
					gun.Handle.FireSound.SoundId = "rbxassetid://2934888536"
				end
			end,
		},
		["pearape"] = {
			["ListName"] = "earape / loud / loudnoise",
			["Description"] = "Makes a loud sound for everyone",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				if loudsound then
					loudsound = false
					notify("Earape", "Loud noise stopped")
				else
					loud()
					notify("Earape", "Loud noise started")
				end
			end,
		},
		["padmin"] = {
			["ListName"] = "admin [plr]",
			["Description"] = "Admins a peep til you rejoin",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local targets = getPlayer(args[1], speaker)
				for _, plr in pairs(targets) do
					if not table.find(ge().PLCdata.admin.admins, plr) then
						table.insert(ge().PLCdata.admin.admins, plr)
					end
				end
			end,
		},
		["punadmin"] = {
			["ListName"] = "unadmin [plr]",
			["Description"] = "Unadmins a peep til you rejoin. Unless you admined them",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local targets = getPlayer(args[1], speaker)
				for _, plr in pairs(targets) do
					local plr = table.find(ge().PLCdata.admin.admins, plr)
					if plr then
						table.remove(ge().PLCdata.admin.admins, plr)
					end
				end
				local a = args[1]:lower()
				for i, plr in pairs(ge().PLCdata.admin.admins) do
					if string.sub(plr, 1, a:len()):lower() == a then
						table.remove(ge().PLCdata.admin.admins, i)
					end
				end
			end,
		},
		["pgetadmins"] = {
			["ListName"] = "getadmins / chatnotifyadmins",
			["Description"] = "Tells you admins in chat",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				game:GetService("StarterGui"):SetCore("ChatMakeSystemMessage", {Text = "Admins list:"})
				for _, plr in pairs(ge().PLCdata.admin.admins) do
					if not table.find(ge().PLCdata.admin.superadmins, plr) then
						local col = nil
						if Players:FindFirstChild(plr) then
							col = Color3.fromRGB(255, 255, 41)
						else
							col = Color3.fromRGB(171, 171, 171)
						end
						game:GetService("StarterGui"):SetCore("ChatMakeSystemMessage", {Text = plr..": Admin", Color = col})
					end
				end
				for _, plr in pairs(ge().PLCdata.admin.superadmins) do
					local col = nil
					if Players:FindFirstChild(plr) then
						col = Color3.fromRGB(247, 45, 45)
					else
						col = Color3.fromRGB(171, 171, 171)
					end
					game:GetService("StarterGui"):SetCore("ChatMakeSystemMessage", {Text = plr..": Super Admin", Color = col})
				end
			end,
		},
		["pgetloadouts"] = {
			["ListName"] = "getloadouts / chatnotifyloadouts",
			["Description"] = "Tells you your saved loadouts in chat",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				game:GetService("StarterGui"):SetCore("ChatMakeSystemMessage", {Text = "Loadouts list:"})
				formatFile()
				local data = JSONload()
				for name, _ in pairs(data["Loadouts"]) do
					game:GetService("StarterGui"):SetCore("ChatMakeSystemMessage", {Text = name, Color = Color3.fromRGB(247, 45, 45)})
				end
			end,
		},
		["pgetgunmods"] = {
			["ListName"] = "getgunmods / chatnotifygunmods",
			["Description"] = "Tells you your saved gunmods in chat",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				game:GetService("StarterGui"):SetCore("ChatMakeSystemMessage", {Text = "Gunmods list:"})
				formatFile()
				local data = JSONload()
				for name, _ in pairs(data["Gunmods"]) do
					game:GetService("StarterGui"):SetCore("ChatMakeSystemMessage", {Text = name, Color = Color3.fromRGB(247, 45, 45)})
				end
			end,
		},
		["pcar"] = {
			["ListName"] = "car",
			["Description"] = "Spawn a car where the speaker is at",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local type = "Squad"
				local button = nil
				for _, v in pairs(workspace["Prison_ITEMS"].buttons:GetChildren()) do
					if v.Name == "Car Spawner" then
						if v["Car Spawner"].type.Value == type then
							button = v["Car Spawner"]
						end
					end
				end
				coroutine.resume(coroutine.create(function()
					workspace.Remote.ItemHandler:InvokeServer(button)
				end))
				local car = nil
				local con = workspace.CarContainer.ChildAdded:Connect(function(c)
					car = c
				end)
				local WT = elapsedTime() + 4
				repeat
					RS.RenderStepped:Wait()
				until car or elapsedTime() > WT
				con:Disconnect()
				wait()
				if car then
					car:WaitForChild("Body"):WaitForChild("VehicleSeat"):WaitForChild("ReadyToSpawn")
					local wheels = car.Wheels
					local seat = car.Body.VehicleSeat
					local root = getRoot(Players.LocalPlayer.Character)
					local hum = Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
					local root2 = getRoot(speaker.Character)
					local offset = CFrame.new(0, 1, 0) * CFrame.Angles(0, math.rad(90), math.rad(90))
					local pos = root2.CFrame * offset
					local looping = true
					local up = true
					RS:BindToRenderStep("PLCcarattach", 1, function()
						if up then
							root.CFrame = seat.CFrame * CFrame.new(1, 1, 1)
						else
							root.CFrame = seat.CFrame
						end
						up = not up
					end)
					seat:GetPropertyChangedSignal("Occupant"):Wait()
					RS:UnbindFromRenderStep("PLCcarattach")
					looping = false
					car.PrimaryPart = car.Body.Main
					car:SetPrimaryPartCFrame(pos)
					for _, wheel in pairs(wheels:GetChildren()) do
						wheel.CFrame = pos
						wheel.Anchored = true
					end
					wait(0.1)
					for _, wheel in pairs(wheels:GetChildren()) do
						wheel.Anchored = false
					end
				else
					notify("Can't spawn", "Took to long to spawn a car. Is the server lagging?")
				end
			end,
		},
		["pdeletecar"] = {
			["ListName"] = "deletecar / removecar",
			["Description"] = "Attempts to delet the car you're in, if it fails then it removes ur drivers license til you respawn",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local hum = Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
				local seat = hum.SeatPart
				if seat then
					local car = seat.Parent.Parent
					if car then
						local wheels = car.Wheels
						local root = getRoot(Players.LocalPlayer.Character)
						local current = root.CFrame
						car.PrimaryPart = car.Body.Main
						local delet = Instance.new("BodyPosition", car.PrimaryPart)
						delet.Position = (void * CFrame.new(0, 500, 0)).Position
						delet.MaxForce = Vector3.new("inf", "inf", "inf")
						wait(1)
						hum.Sit = false
						delet:Destroy()
						local CT = os.clock() + 0.4
						while CT > os.clock() do
							RS.RenderStepped:Wait()
							hum.Sit = false
							root.CFrame = current
							root.Velocity = Vector3.new(0, 0, 0)
							root.RotVelocity = Vector3.new(0, 0, 0)
							if not seat or seat.Parent == nil then
								break
							end
						end
					end
				end
			end,
		},
		["ptogglefastbring"] = {
			["ListName"] = "togglefastbring [on/off]",
			["Description"] = "Toggles the fastbring mode",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local arg = tostring(args[1]):lower()
				if arg == "on" then
					ge().PLCdata.fastbring = true
					notfiy("Enabled", "Fastbring was enabled")
				elseif arg == "off" then
					ge().PLCdata.fastbring = false
					notfiy("Disabled", "Fastbring was disabled")
				else
					notfiy("Invalid", "Invalid argument. Do 'on/off'")
				end
			end,
		},
		["pfasteat"] = {
			["ListName"] = "fasteat / hungry (hold food)",
			["Description"] = "You can eat fast and a lot (hold food)",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local character = Players.LocalPlayer.Character
				local tool = character:FindFirstChildOfClass("Tool")
				tool.ToolTip = "I'm very hungry."
				tool.LocalScript.Disabled = true
				tool.Equipped:connect(function(p1)
					p1.Button1Down:connect(function()
						local sound = tool.Handle:FindFirstChild("EatSound") or tool.Handle:FindFirstChild("DrinkSound")
						sound:Play()
						character.Humanoid:LoadAnimation(tool.Animation):Play()
						character.Humanoid.Health = character.Humanoid.Health + 15
					end)
				end)
				character.Humanoid:UnequipTool(tool)
			end,
		},
		["pantitase"] = { -- "Those annoying taser spammers are no match for you"
			["ListName"] = "antitase / notase / tase=bad",
			["Description"] = "Well, you cant get tased. Doesent get any simpler than that",
			["Aliases"] = {"pnotase"},
			["Function"] = function(args, speaker)
				if getconnections then
					local arg = tostring(args[1]):lower()
					if arg == "on" then
						local ev = workspace.Remote.tazePlayer.OnClientEvent
						RebindRender("ANTI_TASE", function()
							local connections = getconnections(ev)
							for _, con in pairs(connections) do
								con:Disable()
							end
						end)
						notify("Enabled", "Anti-tase was enabled")
					elseif arg == "off" then
						UnbindRender("ANTI_TASE")
						notify("Disabled", "Anti-tase was disabled")
					else
						notfiy("Invalid", "Invalid argument. Do 'on/off'")
					end
				else
					notify("Incompatible Exploit", "Your exploit does not support this command (missing getconnections) and anti-tase will not work")
				end
			end,
		},
		["panticrash"] = {
			["ListName"] = "anticrash / nocrash [on/off]",
			["Description"] = "Prevents you from being gun crashed by disabling bullet rays",
			["Aliases"] = {"pnocrash"},
			["Function"] = function(args, speaker)
				if getconnections then
					if args[1] then
						local enabled = args[1]:lower()
						local rem = game:GetService("ReplicatedStorage"):WaitForChild("ReplicateEvent")
						local connections = getconnections(rem.OnClientEvent)
						if enabled == "on" then
							for _, con in pairs(connections) do
								con:Disable()
							end
							notify("Anti-crash", "Anti crash was enabled")
						elseif enabled == "off" then
							for _, con in pairs(connections) do
								con:Enable()
							end
							notify("Anti-crash", "Anti crash was disabled")
						else
							notify("Invalid", "Invalid args. (Do on/off)")
						end
					end
				else
					notify("Incompatible Exploit", "Your exploit does not support this command (missing getconnections) and anti-crash will not work")
				end
			end,
		},
		["pcamlookat"] = {
			["Description"] = "temporary lol",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local t = Players:FindFirstChild(getPlayer(args[1], speaker)[1])
				if t and t.Character and t.Character.Head then
					workspace.CurrentCamera.CFrame = CFrame.new(workspace.CurrentCamera.CFrame.Position, t.Character.Head.Position)
				end
			end,
		},
		["pvirus"] = {
			["ListName"] = "virus [plr]",
			["Description"] = "Makes the player like a lava brick",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local targets = getPlayer(args[1], speaker)
				for _, v in ipairs(targets) do
					local target = Players[v]
					local name = "GIVE_VIRUS_"..target.Name
					local processing = {}
					local function find(v)
						for _, i in pairs(processing) do
							if i[1] == v then
								return true
							end
						end
						return
					end
					RebindRender(name, function()
						if not target or target == nil or not target.Parent or target.Parent == nil then
							UnbindRender(name)
							return
						end
						if not cooldown and target.Character then
							for _, plr in pairs(Players:GetPlayers()) do
								if IsAlive(plr) and IsVulnerable(plr) and IsClose(plr, target, 3) and plr ~= target and plr ~= Players.LocalPlayer and not find(plr.Character) then
									table.insert(processing, {plr.Character, os.clock() + 0.5})
									GunKill(plr.Name)
								end
							end
						end
						local new = processing
						for i, data in pairs(processing) do
							if data and data[2] < os.clock() then
								new[i] = nil
							end
						end
						processing = new
					end)
				end
			end,
		},
		["punvirus"] = {
			["ListName"] = "unvirus / cure [plr]",
			["Description"] = "Removes virus from a player",
			["Aliases"] = {"pcure"},
			["Function"] = function(args, speaker)
				local targets = getPlayer(args[1], speaker)
				for _, v in ipairs(targets) do
					local target = Players[v]
					local name = "GIVE_VIRUS_"..target.Name
					UnbindRender(name)
				end
			end,
		},
		["pgiveaura"] = {
			["ListName"] = "giveaura [plr]",
			["Description"] = "Gives kill aura to a player",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local targets = getPlayer(args[1], speaker)
				for _, v in ipairs(targets) do
					local target = Players[v]
					local name = "GIVE_KILL_aura_"..target.Name
					local processing = {}
					local function find(v)
						for _, i in pairs(processing) do
							if i[1] == v then
								return true
							end
						end
						return
					end
					RebindRender(name, function()
						if not target or target == nil or not target.Parent or target.Parent == nil then
							UnbindRender(name)
							return
						end
						if not cooldown and target.Character then
							for _, plr in pairs(Players:GetPlayers()) do
								if IsAlive(plr) and IsVulnerable(plr) and IsClose(plr, target) and plr ~= target and plr ~= Players.LocalPlayer and not find(plr.Character) then
									table.insert(processing, {plr.Character, os.clock() + 0.5})
									GunKill(plr.Name)
								end
							end
						end
						local new = processing
						for i, data in pairs(processing) do
							if data and data[2] < os.clock() then
								new[i] = nil
							end
						end
						processing = new
					end)
				end
			end,
		},
		["premoveaura"] = {
			["ListName"] = "removeaura [plr]",
			["Description"] = "Removes kill aura from a player",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local targets = getPlayer(args[1], speaker)
				for _, v in ipairs(targets) do
					local target = Players[v]
					local name = "GIVE_KILL_aura_"..target.Name
					UnbindRender(name)
				end
			end,
		},
		["pjoinjobid"] = {
			["ListName"] = "joinjobid [jobid] [placeid]",
			["Description"] = "Join a server from a jobid",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				game:GetService("TeleportService"):TeleportToPlaceInstance(args[2] or game.PlaceId, args[1], Players.LocalPlayer)
			end,
		},
		["pkey"] = {
			["ListName"] = "key [plr]",
			["Description"] = "Give somebody or yourself a keycard",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local Color = tostring(Players.LocalPlayer.TeamColor)
				local waiting = true
				local c = 0
				Team("g")
				repeat
					c = c + 1
					if Players.LocalPlayer.TeamColor == BrickColor.new("Bright blue") then
						waiting = false
					end
					if c > 240 then
						break
					end 
					RS.Heartbeat:Wait()
				until not waiting
				if not waiting then
					local pickup = nil
					local NormPos = getRoot(Players.LocalPlayer.Character).CFrame
					for _, v in ipairs(getPlayer(args[1], speaker)) do
						local target = Players[v]
						local attempts = 0
						local found = workspace["Prison_ITEMS"].single:FindFirstChild("Key card")
						while attempts < 10 and not found and target do
							Players.LocalPlayer.Character:BreakJoints()
							Respawn()
							found = workspace["Prison_ITEMS"].single:FindFirstChild("Key card")
							attempts = attempts + 1
						end
						if found and target then
							pickup = found:FindFirstChild("ITEMPICKUP")
							if pickup and target and target ~= Players.LocalPlayer and IsAlive(target) then
								workspace.Remote.ItemHandler:InvokeServer(pickup)
								local tool = Players.LocalPlayer.Backpack:WaitForChild("Key card")
								whitelisted = tool
								tool.Parent = Players.LocalPlayer.Backpack
								attach(Players.LocalPlayer, target, tool)
								Respawn(NormPos)
							end
						end
					end
					TeamColor(Players.LocalPlayer, {Color})
					if not args[1] or args[1]:len() == 0 then
						workspace.Remote.ItemHandler:InvokeServer(pickup)
					end
				else
					notify("Couldent give/get key", "Took too long to switch to cops team, or its full")
				end
			end,
		},
		["pclickkill"] = {
			["ListName"] = "clickkill / ck",
			["Description"] = "Get a click to kill tool",
			["Aliases"] = {"pck"},
			["Function"] = function(args, speaker)
				local CK = Instance.new("Tool", Players.LocalPlayer.Backpack)
				CK.Name = "CK"
				CK.RequiresHandle = false
				CK.Equipped:Connect(function(mouse)
					mouse.Button1Down:Connect(function()
						local target = mouse.Target
						local char = target.Parent
						local plr = Players:GetPlayerFromCharacter(char) or Players:GetPlayerFromCharacter(char.Parent)
						if plr then
							GunKill(plr.Name)
						end
					end)
				end)
			end,
		},
		["panticrim"] = {
			["ListName"] = "anticrim [on/off]",
			["Description"] = "Prevents you form becomeing a criminal",
			["Aliases"] = {"pnocrim"},
			["Function"] = function(args, speaker)
				local arg = args[1]:lower()
				local spawns = workspace["Criminals Spawn"]:GetChildren()
				if arg == "on" then
					anticrim = true
					for _, spawn in pairs(spawns) do
						spawn.CanTouch = false
					end
					notify("Enabled", "Anti-crim was turned on (Server will make you crim if you're inmate and escaped)")
				elseif arg == "off" then
					anticrim = false
					for _, spawn in pairs(spawns) do
						spawn.CanTouch = true
					end
					notify("Disabled", "Anti-crim was turned off")
				else
					notify("Invalid", "Invalid argument. Do 'on/off'")
				end
			end,
		},
		["pantibring"] = {
			["ListName"] = "antibring / nobring / ab [on/off]",
			["Description"] = "Prevents bring people from bringing you",
			["Aliases"] = {"pnobring"},
			["Function"] = function(args, speaker)
				local arg = args[1]:lower()
				if arg == "on" then
					antibring = true
					notify("Enabled", "Anti-bring was turned on")
				elseif arg == "off" then
					antibring = false
					notify("Disabled", "Anti-bring was turned off")
				else
					notify("Invalid", "Invalid argument. Do 'on/off'")
				end
			end,
		},
		["clickarrest"] = {
			["ListName"] = "clickarrest / ca [amt]",
			["Description"] = "Get a click to arrest tool",
			["Aliases"] = {"ca"},
			["Function"] = function(args, speaker)
				local amt = math.floor(tonumber(args[1]) or 1)
				local CA = Instance.new("Tool", game.Players.LocalPlayer.Backpack)
				CA.Name = "CA"
				CA.RequiresHandle = false
				CA.Equipped:Connect(function(mouse)
					mouse.Button1Down:Connect(function()
						local target = mouse.Target
						function isplr(char)
							return Players:GetPlayerFromCharacter(char)
						end
						local char = (isplr(target.Parent) and target.Parent) or (isplr(target.Parent.Parent) and target.Parent.Parent)
						if char then
							if isArrestable(isplr(char)) then
								local root = char:FindFirstChild("HumanoidRootPart") or char:FindFirstChildOfClass("BasePart")
								if root then
									for _ = 1, amt do
										coroutine.resume(coroutine.create(function()
											workspace.Remote.arrest:InvokeServer(root)
										end))
									end
								end
								prisonnotify("Successfully arrested!")
							else
								prisonnotify("You cant currently arrest this player!")
							end
						end
					end)
				end)
			end,
		},
		["gaming"] = {
			["ListName"] = "gaming",
			["Description"] = "Basically gives you every command",
			["Aliases"] = {"gameing"},
			["Function"] = function(args, speaker)
				speaker = Players.LocalPlayer
				Run("pteamcolor", {"Really", "black"}, speaker)
				Run("pauto", {"on"}, speaker)
				Run("panticrim", {"on"}, speaker)
				Run("pantibring", {"on"}, speaker)
				Run("panticrash", {"on"}, speaker)
				Run("pantitase", {"on"}, speaker)
				wait(1)
				notify("Gaming", "Autorespawn, anti-crim, anti-bring, anti-crash, antitase, was turned on")
			end,
		},
		["map"] = {
			["ListName"] = "map [map part] [on/off]",
			["Description"] = "Shows or hides a part of the map",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local map = args[1]:lower()
				local arg = args[2]:lower()
				local parts = ge().PLCdata.mapParts[map]
				if parts then
					if arg == "on" then
						for _, v in pairs(parts) do
							v[1].Parent = v[2]
						end
					elseif arg == "off" then
						for _, v in pairs(parts) do
							v[1].Parent = nil
						end
					else
						notify("Invalid", "Invalid argument. Do 'on/off'")
					end
				else
					notify("Invalid", "Invalid argument, current map parts are 'roof/walls'")
				end
			end,
		},
		["roof"] = {
			["ListName"] = "roof [on/off]",
			["Description"] = "Shows or hides the roof",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local arg = args[1]:lower()
				if arg == "on" then
					for _, v in pairs(ge().PLCdata.mapParts.roof) do
						v[1].Parent = v[2]
					end
				elseif arg == "off" then
					for _, v in pairs(ge().PLCdata.mapParts.roof) do
						v[1].Parent = nil
					end
				else
					notify("Invalid", "Invalid argument. Do 'on/off'")
				end
			end,
		},
		["walls"] = {
			["ListName"] = "walls [on/off]",
			["Description"] = "Shows or hides the walls",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local arg = args[1]:lower()
				if arg == "on" then
					for _, v in pairs(ge().PLCdata.mapParts.walls) do
						v[1].Parent = v[2]
					end
				elseif arg == "off" then
					for _, v in pairs(ge().PLCdata.mapParts.walls) do
						v[1].Parent = nil
					end
				else
					notify("Invalid", "Invalid argument. Do 'on/off'")
				end
			end,
		},
		["plccredit"] = {
			["ListName"] = "PLCcredit",
			["Description"] = "Shows credits on the top bar",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local bar = Players.LocalPlayer.PlayerGui.Home.hud.Topbar
				bar.GuiScript.Disabled = true
				bar.Pulldownmenu.LocalScript.Disabled = true
				local pull = bar.Pulldownmenu
				local tb = pull.tb
				local state = false
				tb.MouseButton1Click:connect(function()
					if not state then
						pull:TweenSize(UDim2.new(0.3, 0, 4, 0), "Out", "Quart", 0.5, true)
						tb.Text = "Click to hide credits"
					else
						pull:TweenSize(UDim2.new(0.3, 0, 0, 0), "Out", "Quart", 0.5, true)
						tb.Text = "Click to show credits"
					end
					state = not state
				end)
				bar.titleBar.Title.Text = "PLC"
				tb.Text = "Click to show credits"
				pull.Frame.Description.Text = "PLC - one of the best prison life plugins\nDeveloped by: McTurtles5 on github\nMcTurtles5/PLC"
				RS.RenderStepped:Connect(function()
					bar.titleBar.BackgroundColor3 = currentShade1
					tb.BackgroundColor3 = currentShade1
					pull.BackgroundColor3 = currentShade2
					tb.TextColor3 = currentText1
					pull.Frame.Description.TextColor3 = currentText1
					bar.titleBar.Title.TextColor3 = currentText1
				end)
			end,
		},
		["spamarrest"] = {
			["ListName"] = "spamarrest / sa [plr] [forcecrim (y/n)] [APS] (one player)",
			["Description"] = "Spam arrests a player, antilag is reccomended. APS is Arrests Per Second",
			["Aliases"] = {"sa"},
			["Function"] = function(args, speaker)
				local aps = tonumber(args[3]) or 2000
				local target = Players[getPlayer(args[1], speaker)[1]]
				if spamming then
					notify("Spam arrest", "There are multiple spam arrests now")
				end
				spamming = true
				local force = tostring(args[2])
				if force == "n" then
					force = false
				else
					force = true
				end
				local bind = nil
				local remote = workspace.Remote.arrest
				local function arrest(root)
					coroutine.resume(coroutine.create(function()
						remote:InvokeServer(root)
					end))
				end
				local last = os.clock()
				local starttime = os.clock()
				local level = 10
				local highlevel = false
				local start = getRoot(Players.LocalPlayer.Character).CFrame
				local crims = game:GetService("Teams").Criminals
				local lastcrim = 0
				local criming = false
				notify("Spam arrest", "Do ;stopsa to stop the spam arrest")
				bind = RS.RenderStepped:Connect(function(d)
					if force and not isArrestable(target) and (lastcrim < os.clock() or not criming) then
						lastcrim = os.clock() + 3
						criming = true
						if firetouchinterest then
							fastCriminal(Players.LocalPlayer, target)
						else
							prisonteleport(Players.LocalPlayer, target, workspace["Criminals Spawn"].SpawnLocation.CFrame, false)
						end
						criming = false
						highlevel = true
					end
					if highlevel then
						level = math.max(1, math.floor(aps * d))
					end
					local char = target.Character
					local root = getRoot(char) or char:FindFirstChildOfClass("BasePart")
					local me = Players.LocalPlayer.Character
					if char and firetouchinterest then
						Criminal(target)
					end
					if me and os.clock() - last > 0.2 then
						local root2 = getRoot(me) or me:FindFirstChildOfClass("BasePart")
						if root2 then
							root2.CFrame = root.CFrame
							root2.Velocity = Vector3.new(0, 0, 0)
						end
						last = os.clock()
					end
					if not spamming then
						bind:Disconnect()
						if me then
							local root = getRoot(me) or me:FindFirstChildOfClass("BasePart")
							if root then
								root.CFrame = start
							end
						end
						notify("Spam arrest", "Spam arrest stopped")
						return
					end
					if not (target and target.Parent) then
						bind:Disconnect()
						spamming = false
						notify("Spam arrest", "Spam arrest cancelled (player left)")
					end
					if isArrestable(target) then
						for _ = 1, level do
							arrest(root)
						end
					end
				end)
			end,
		},
		["cancelspamarrest"] = {
			["ListName"] = "cancelspamarrest / stopspamarrest / stopsa",
			["Description"] = "Stops the current spam arrest",
			["Aliases"] = {"stopspamarrest", "stopsa"},
			["Function"] = function(args, speaker)
				spamming = false
			end,
		},
		["nohit"] = {
			["ListName"] = "nohit / antihit [plr]",
			["Description"] = "Makes you unable to damage a player with guns regardless of teams",
			["Aliases"] = {"antihit"},
			["Function"] = function(args, speaker)
				local plrs = getPlayer(args[1], speaker)
				for _, plr in pairs(plrs) do
					table.insert(ge().PLCdata.nohit, plr)
				end
			end,
		},
		["clrnohit"] = {
			["ListName"] = "clrnohit",
			["Description"] = "Clears the nohit players",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				ge().PLCdata.nohit = {}
			end,
		},
		["timeout"] = {
			["ListName"] = "timeout / lag [on/off]",
			["Description"] = "Lags the server until turned off",
			["Aliases"] = {"lag"},
			["Function"] = function(args, speaker)
				local arg = args[1]:lower()
				if arg == "on" then
					timeout = true
					notify("Enabled", "Timeout was turned on (dont use ak)")
				elseif arg == "off" then
					timeout = false
					notify("Disabled", "Timeout was turned off")
				else
					notify("Invalid", "Invalid argument. Do 'on/off'")
				end
			end,
		},
		["spike"] = {
			["ListName"] = "spike / lagspike [amount?]",
			["Description"] = "Briefly lags the server",
			["Aliases"] = {"lagspike"},
			["Function"] = function(args, speaker)
				local amount = tonumber(args[1]) or 20
				for _ = 1, amount do
					spike()
				end
			end,
		},
		["joincommand"] = {
			["ListName"] = "joincommand",
			["Description"] = "Copies the join command that can be used to joi this server",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				toClipboard("joinjobid "..game.JobId.." "..game.PlaceId)
			end,
		},
		["looptpkill"] = {
			["ListName"] = "looptpkill / ltk [plr]",
			["Description"] = "Effectively loop kills a player by teleporting to them (ONLY ONE PLR)",
			["Aliases"] = {"ltk"},
			["Function"] = function(args, speaker)
				local plrs = getPlayer(args[1], speaker)
				local plr = Players[plrs[1]]
				if plr then
					local last = os.clock()
					local lastchar = nil
					RebindRender("LOOP_TP_KILL", function()
						if not plr then
							UnbindRender("LOOP_TP_KILL")
						end
						local char = plr.Character
						local mychar = Players.LocalPlayer.Character
						if last < os.clock() or char ~= lastchar then
							if char and mychar then
								Goto(plr, mychar)
								Kill(plr)
							end
							last = os.clock() + 0.4
						end
						lastchar = char
					end)
				end
			end,
		},
		["unlooptpkill"] = {
			["ListName"] = "unlooptpkill / unltk [plr]",
			["Description"] = "Stops the current loopkill",
			["Aliases"] = {"unltk"},
			["Function"] = function(args, speaker)
				UnbindRender("LOOP_TP_KILL")
			end,
		},
		["skydive"] = {
			["ListName"] = "skydive / drop [plr] [dist?]",
			["Description"] = "Teleports a player a certain distance above themselves",
			["Aliases"] = {"drop"},
			["Function"] = function(args, speaker)
				local players = getPlayer(args[1], speaker)
				local dist = tonumber(args[2]) or 210
				for _, v in pairs(players) do
					local root = getRoot(Players[v].Character) or Players[v].Character:FindFirstChildOfClass("BasePart")
					if not root then return end
					local bringpos = CFrame.new(root.Position + Vector3.new(0, dist, 0))
					prisonteleport(Players.LocalPlayer, Players[v], bringpos)
				end
			end,
		},
		["damagemul"] = {
			["ListName"] = "damagemul / dmgmul [mul?]",
			["Description"] = "Sets the gun damage multiplier (MAY CAUSE SERVER LAG)",
			["Aliases"] = {"dmgmul"},
			["Function"] = function(args, speaker)
				ge().PLCdata.dmgmul = math.floor(tonumber(args[1]) or 1)
			end,
		},
		["antiwarning"] = {
			["ListName"] = "antiwarning / aw [on/off]",
			["Description"] = "Makes it so that you can't damage innocent players",
			["Aliases"] = {"aw"},
			["Function"] = function(args, speaker)
				local arg = args[1]:lower()
				if arg == "on" then
					RebindRender("ANTI_WARNING", function()
						table.clear(innocents)
						for _, plr in pairs(Players:GetPlayers()) do
							if not isHostile(plr) then
								table.insert(innocents, plr.Name)
							end
						end
					end)
					notify("Enabled", "Antiwarning was enabled")
				elseif arg == "off" then
					UnbindRender("ANTI_WARNING")
					table.clear(innocents)
					notify("Disabled", "Antiwarning was disabled")
				else
					notify("Invalid", "Invalid argument. Do 'on/off'")
				end
			end,
		},
		["nocollide"] = {
			["ListName"] = "nocollide / nc [plr]",
			["Description"] = "Makes it so that you can't collide with the player, to prevent flings",
			["Aliases"] = {"nc"},
			["Function"] = function(args, speaker)
				local players = getPlayer(args[1], speaker)
				for _, v in pairs(players) do
					local plr = Players[v]
					RebindRender("NO_COLLIDE_"..v, function()
						if not plr or not plr.Parent then
							UnbindRender("NO_COLLIDE_"..v)
						end
						local c = plr.Character
						if c then
							for _, p in pairs(c:GetDescendants()) do
								if p:IsA("BasePart") then
									p.CanCollide = false
								end
							end
						end
					end, RS.Stepped)
				end
			end,
		},
		["unnocollide"] = {
			["ListName"] = "unnocollide / unnc [plr]",
			["Description"] = "Stops nocollide",
			["Aliases"] = {"unnc"},
			["Function"] = function(args, speaker)
				local players = getPlayer(args[1], speaker)
				for _, v in pairs(players) do
					UnbindRender("NO_COLLIDE_"..v)
				end
			end,
		},
		["deathcar"] = {
			["ListName"] = "deathcar / deadlycar",
			["Description"] = "Stops nocollide",
			["Aliases"] = {"deadlycar"},
			["Function"] = function(args, speaker)local Players = game:GetService("Players")
				local seat = Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid").SeatPart
				if seat then
					local car = seat.Parent.Parent
					if car then
						local cp = car.Body:FindFirstChild("ColorParts") or car.Body:FindFirstChild("Model")
						local hitbox = Instance.new("Part", car)

						local z = 1.8
						if cp.Name == "Model" then
							z = -10
						end

						hitbox.CanCollide = false
						hitbox.Transparency = 0.5

						hitbox.Massless = true
						hitbox.CFrame = cp.Engine.CFrame * CFrame.new(0, 0.6, z)
						hitbox.Size = Vector3.new(8, 2.8, 6)

						local w = Instance.new("WeldConstraint", hitbox)

						w.Part0 = hitbox
						w.Part1 = cp.Engine

						hitbox.Touched:Connect(function(hit)
							local p = Players:GetPlayerFromCharacter(hit.Parent)
							if p and p ~= Players.LocalPlayer and IsAlive(p) and IsVulnerable(p) then
								for _ = 1, 10 do
									game:GetService("ReplicatedStorage").meleeEvent:FireServer(p)
								end
							end
						end)
						return
					end
				end
				notify("Error", "Sit in a car first!")
			end,
		},
		["fastcriminal"] = {
			["ListName"] = "fastcriminal / fcrim [plr]",
			["Description"] = "Criminal but faster",
			["Aliases"] = {"fcrim"},
			["Function"] = function(args, speaker)
				local players = getPlayer(args[1], speaker)
				for _, v in pairs(players) do
					fastCriminal(Players.LocalPlayer, Players[v])
				end
			end,
		},
		["advertisePLC"] = {
			["ListName"] = "advertisePLC",
			["Description"] = "Chats how to get PLC in chat",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				Chat("Get PLC, short for Prison Life Commands. You can find it on github by searching:")
				Chat("McTurtles5/PLC")
				Chat("-- If you need help then click Wiki on the  github repository")
			end,
		},
		["arrestaura"] = {
			["ListName"] = "arrestaura / aa",
			["Description"] = "Arrests players near you",
			["Aliases"] = {"aa"},
			["Function"] = function(args, speaker)
				local arg = args[1]:lower()
				if arg == "on" then
					local Teams = game:GetService("Teams")
					RebindRender("ARREST_aura", function()
						for _, plr in pairs(game:GetService("Players"):GetPlayers()) do
							if (plr.Team == Teams.Inmates or plr.Team == Teams.Criminals) and IsAlive(plr) and IsClose(plr, speaker) and plr ~= speaker then
								local root = getRoot(plr.Character) or plr.Character:FindFirstChildOfClass("BasePart")
								coroutine.resume(coroutine.create(function()
									workspace.Remote.arrest:InvokeServer(root)
								end))
							end
						end
					end)
					notify("Enabled", "Arrest aura was enabled")
				elseif arg == "off" then
					UnbindRender("ARREST_aura")
					notify("Disabled", "Arrest aura was disabled")
				else
					notify("Invalid", "Invalid argument. Do 'on/off'")
				end
			end,
		},
		["antiarrest"] = {
			["ListName"] = "antiarrest / noarrest",
			["Description"] = "Prevents the arrest animation when you get arrested",
			["Aliases"] = {"noarrest"},
			["Function"] = function(args, speaker)
				if getconnections then
					local arg = tostring(args[1]):lower()
					if arg == "on" then
						local ev = workspace.Remote.arrestPlayer.OnClientEvent
						RebindRender("ANTI_ARREST", function()
							local connections = getconnections(ev)
							for _, con in pairs(connections) do
								con:Disable()
							end
						end)
						notify("Enabled", "Anti-arrest was enabled")
					elseif arg == "off" then
						UnbindRender("ANTI_ARREST")
						notify("Disabled", "Anti-arrest was disabled")
					else
						notfiy("Invalid", "Invalid argument. Do 'on/off'")
					end
				else
					notify("Incompatible Exploit", "Your exploit does not support this command (missing getconnections) and anti-tase will not work")
				end
			end,
		},
		["killcar"] = {
			["ListName"] = "killcar [seat?]",
			["Description"] = "Kills the player in the seat of your car or everyone. eg: killcar frontleft",
			["Aliases"] = {"noarrest"},
			["Function"] = function(args, speaker)
				local seat = Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid").SeatPart
				if seat then
					local car = seat.Parent
					if car then
						local killtable = {}
						local function killseat(seat)
							local plr = seat and seat.Occupant and seat.Occupant.Parent and Players:GetPlayerFromCharacter(seat.Occupant.Parent)
							if plr and plr ~= Players.LocalPlayer then
								table.insert(killtable, plr.Name)
							end
						end
						local arg = table.concat(args, " "):lower()
						local seats = {
							["Driver"] = nil,
							["FR"] = nil,
							["BR"] = nil,
							["BL"] = nil
						}
						seats.Driver = car.VehicleSeat
						local function off(cf1, cf2)
							return cf1:Inverse() * cf2
						end
						local foundc = 0
						for _, seat in pairs(car:GetChildren()) do
							if foundc >= 3 then
								break
							end
							if seat:IsA("Seat") then
								foundc = foundc + 1
								local off = off(seats.Driver.CFrame, seat.CFrame)
								local X, Z = off.X > 3, off.Z > 4
								if X and Z then
									seats.BR = seat
								elseif X then
									seats.FR = seat
								elseif Z then
									seats.BL = seat
								end
							end
						end
						if arg ~= "" then
							local front, right, back, left = arg:find("front"), arg:find("right"), arg:find("back"), arg:find("left")
							local driver = arg:find("drive")
							local targetseat = nil
							if driver or (front and left) then
								targetseat = seats.Driver
							elseif front and right then
								targetseat = seats.FR
							elseif back and left then
								targetseat = seats.BL
							elseif back and right then
								targetseat = seats.BR
							end
							killseat(targetseat)
						else
							killseat(seats.Driver)
							killseat(seats.FR)
							killseat(seats.BL)
							killseat(seats.BR)
						end
						if #killtable > 0 then
							GunKill(killtable)
						end
						return
					end
				end
				notify("Error", "Sit in a car first!")
			end,
		},
		["cmdsPLC"] = {
			["ListName"] = "cmdsPLC",
			["Description"] = "Currently not functional, just scroll down on infinite yeild",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				print(pcall(function()
					wait(0.2)
					maximizeHolder()
					local y = 500
					print(CMDsF:GetFullName())
					for _, e in pairs(CMDsF:GetChildren()) do
						if e:IsA("TextButton") and e.Text == "--PRISON ADMIN" then
							y = e.AbsolutePosition.Y
							break
						end
					end
					if y then
						local s = os.clock()
						local TS = game:GetService("TweenService")
						RebindRender("SCROLLBAR_CONTROL", function()
							CMDsF.CanvasPosition = Vector2.new(TS:GetValue((os.clock() - s) * 0.8, 5, 1) * 500 + 5, 0)
						end)
						wait(0.8)
						UnbindRender("SCROLLBAR_CONTROL")
					--[[game:GetService("TweenService"):Create(CMDsF, TweenInfo.new(0.8, 5, 1), {
						["CanvasPosition"] = Vector2.new(y + 5, 0)
					}):Play()]]
					end
				end))
			end,
		},
		["loot"] = {
			["ListName"] = "loot [on/off]",
			["Description"] = "Loopkills you as a guard to spawn in loot",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local arg = tostring(args[1]):lower()
				if arg == "on" then
					local waiting = true
					local waittime = os.clock() + 4
					Team("g")
					repeat
						if Players.LocalPlayer.TeamColor == BrickColor.new("Bright blue") then
							waiting = false
						end
						if os.clock() > waittime then
							break
						end
						RS.Heartbeat:Wait()
					until not waiting
					if not waiting then
						local NormPos = getRoot(Players.LocalPlayer.Character).CFrame
						local next = os.clock() + 0.5
						RebindRender("GUARD_LOOT", function()
							local root = getRoot(Players.LocalPlayer.Character)
							if root then
								root.CFrame = NormPos
							end
							if os.clock() > next then
								next = os.clock() + 0.5
								local char = Players.LocalPlayer.Character
								if char then
									local hum = char:FindFirstChildOfClass("Humanoid")
									if hum then
										hum.Health = -math.huge
									end
									Respawn()
								end
							end
						end)
					else
						notify("Couldn't begin loot", "Took too long to switch to cops team, or its full")
					end
					notify("Started", "Guard loot was started")
				elseif arg == "off" then
					UnbindRender("GUARD_LOOT")
					notify("Stopped", "Guard loot was stopped")
				else
					notfiy("Invalid", "Invalid argument. Do 'on/off'")
				end
			end,
		},
		["lockdown"] = {
			["ListName"] = "lockdown [on/off]",
			["Description"] = "Uses the best tactics for anti spam arrest",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local arg = tostring(args[1]):lower()
				if arg == "on" then
					lockdownmode = true
					notify("Enabled", "Lockdownmode was turned on")
				elseif arg == "off" then
					lockdownmode = false
					notify("Disabled", "Lockdownmode was turned off")
				else
					notfiy("Invalid", "Invalid argument. Do 'on/off'")
				end
			end,
		},
		--TEMP REMOVE (shhhh. its been 1 year and its still here)













		["clickcrim"] = {
			["ListName"] = "clickcrim / cc",
			["Description"] = "Click dead players to make them a criminal",
			["Aliases"] = {"cc"},
			["Function"] = function(args, speaker)
				local function Touch(x, Root)
					if firetouchinterest then
						return coroutine.resume(coroutine.create(function()
							firetouchinterest(x, Root, 1, wait() and firetouchinterest(x, Root, 0))
						end))
					else
						notify("Incompatible Exploit","Your exploit does not support this command (missing firetouchinterest) this is need to touch the criminal pad")
					end
					x.CFrame = Root.CFrame
				end

				local CK = Instance.new("Tool", game.Players.LocalPlayer.Backpack)
				CK.Name = "CC"
				CK.RequiresHandle = false
				CK.Equipped:Connect(function(mouse)
					mouse.Button1Down:Connect(function()
						local target = mouse.Target
						Touch(workspace["Criminals Spawn"].SpawnLocation, target)
					end)
				end)
			end,
		},

	},
}

loadstring(game:HttpGet("https://raw.githubusercontent.com/McTurtles5/PLC/main/PLC-resources/usagenotify"))()

local Prefix = ":"
--[[

local BasicList = {
	"List of commands, <PRE>crim -Makes the player a crim, <PRE>pris -Brings you to the hosts position, <PRE>death -Toggles loud noise, <PRE>tp -Teleports a player to a player",
	"<PRE>goto -Teleports you to a player, <PRE>bring -Brings a player, <PRE>tase -Tases a player, <PRE>k -Ends a player, <PRE>sk -Ends a player but slower",
	", <PRE>arrest -Arrests a player, <PRE>virus -Makes a player like a lava brick <PRE>aura -Gives the player a deadly aura <PRE>unvirus -Removes virus from a player",
	"<PRE>unaura - Removes aura from a player"
}
local SuperList = {
	"List of super commands, <PRE>crash -Trys to crash the everyone, <PRE>admin -Adds people to admin list, <PRE>unadmin -Removes a players admin",
}

]]

-- Simplified
local BasicList = {
	"List of commands, <PRE>crim [plr] <PRE>pris [plr] <PRE>death <PRE>tp [plr] [plr to] <PRE>goto [plr] <PRE>bring [plr] <PRE>tase [plr] <PRE>k [plr]",
	"<PRE>arrest [plr] <PRE>virus [plr] <PRE>aura [plr] <PRE>unvirus [plr] <PRE>unaura [plr] <PRE>key [plr]"
}
local SuperList = {
	"List of super commands, <PRE>crash <PRE>admin [plr] <PRE>unadmin [plr]",
}
local CommandInfo = {
	["crim"] = "Makes [plr] a criminal",
	["pris"] = "Teleports [plr] to the host (me)",
	["loud"] = "Toggles a loud noise",
	["tp"] = "Teleports [plr] to [plr to]",
	["to"] = "Teleports you to [plr]",
	["bring"] = "Brings [plr] to you",
	["tase"] = "Will tase [plr]",
	["k"] = "Will kill [plr]",
	["arrest"] = "Will try to arrest [plr]",
	["virus"] = "Players will die upon collideing with [plr]",
	["aura"] = "Players will die when they are close to [plr]",
	["unvirus"] = "Removes virus from [plr]",
	["unaura"] = "Removes aura from [plr]",
	["key"] = "Gives a keycard to [plr]",
	["admin"] = "(ONLY FOR SUPER ADMINS) Gives admin to [plr]",
	["unadmin"] = "(ONLY FOR SUPER ADMINS) Removes admin from [plr]"
}

for i, cmd in pairs(BasicList) do
	if cmd then
		BasicList[i] = table.concat(cmd:split("<PRE>"), Prefix)
	end
end
for i, cmd in pairs(SuperList) do
	if cmd then
		SuperList[i] = table.concat(cmd:split("<PRE>"), Prefix)
	end
end

local prefix = ge().PLCdata.admin.prefix
local cmds = {}
for n, d in pairs(PLC["Commands"]) do
	cmds[n] = d
end
function Run(cmd, args, speaker)
	cmds[cmd]["Function"](args, speaker)
end

local pris = CFrame.new(914, 100, 2366)
function Added(plr)
	plr.Chatted:Connect(function(msg)
	print(pcall(function()
		if msg:len() > 512 then
			return
		end
		local isSuper = table.find(ge().PLCdata.admin.superadmins, plr.Name)
		local isBasic = isSuper or table.find(ge().PLCdata.admin.admins, plr.Name)
		if isBasic then
			local isLoudPrefix = string.sub(msg, 1, Prefix:len()):lower() == Prefix
			local isSilentrefix = string.sub(msg, 1, Prefix:len() + 3):lower() == "/e "..Prefix
			if isLoudPrefix or isSilentPrefix then
				local Prefix = Prefix
				if isSilentPrefix then
					Prefix = "/e "..Prefix
				end
				local values = msg:split(Prefix)[2]:split(" ")
				local command = values[1]:lower()
				local args = {}
				for i, arg in pairs(values) do
					if i > 1 then
						args[#args+1] = arg
					end
				end
				if command == "cmds" then
					local found = nil
					if args[1] and args[1] ~= "" then
						local look = args[1]:lower()
						for cmd, info in pairs(CommandInfo) do
							if cmd == look then
								found = "(INFO FOR "..cmd..") "..info
							end
						end
					end
					if found then
						Chat("/w "..plr.Name.." "..found, "All")
					else
						for _, cmd in pairs(BasicList) do
							Chat("/w "..plr.Name.." "..cmd, "All")
						end
					end
				elseif command == "loud" then
					Run("pearape")
				elseif command == "crim" then
					Run("pcriminal", args, plr)
				elseif command == "pris" then
					
					local targets = getPlayer(speaker, args)
					for _, v in pairs(targets) do
						prisonteleport(Players.LocalPlayer, Players[v], pris)
					end
				elseif command == "to" then
					local t = {plr.Name, args[1]}
					Run("pteleport", t, plr)
				elseif command == "bring" then
					local t = {args[1], plr.Name}
					Run("pteleport", t, plr)
				elseif command == "tp" then
					Run("pteleport", args)
				elseif command == "tase" then
					Run("ptase", args, plr)
				elseif command == "k" then
					Run("pfastkill", args, plr)
				elseif command == "arrest" then
					Run("parrest", args, plr)
					args[2] = math.clamp(tonumber(args[2]) or 1, 0, 1000)
				elseif command == "virus" then
					Run("pvirus", args, plr)
				elseif command == "unvirus" then
					Run("punvirus", args, plr)
				elseif command == "aura" then
					Run("pgiveaura", args, plr)
				elseif command == "unaura" then
					Run("premoveaura", args, plr)
				elseif command == "key" then
					Run("pkey", args, plr)
				end
				if isSuper then
					if command == "super" then
						for _, cmd in pairs(SuperList) do
							Chat("/w "..plr.Name.." "..cmd, "All")
						end
					elseif command == "crash" then
						Run("pcrash")
					elseif command == "admin" then
						Run("padmin", args, plr)
					elseif command == "unadmin" then
						Run("punadmin", args, plr)
					end
				end
			end
		end
		end))
	end)
end

if not game:IsLoaded() then
	game.Loaded:Wait()
end
if not ge().PLCdataadminloaded and isPL then
	ge().PLCdataadminloaded = true
	for _, plr in pairs(Players:GetPlayers()) do
		Added(plr)
	end
	Players.PlayerAdded:Connect(Added)
end

--[[rconsoleclear()
function p(...)
	for _, m in pairs({...}) do
		rconsoleprint(tostring(m).." ")
	end
	rconsoleprint("\n")
end
for n, c in pairs(PLC["Commands"]) do
	p(n, unpack(c["Aliases"]), c["Description"])
end]]

local addcases = {
	["visible"] = function(speaker,args)
		local returns = {}
		local speakerChar = speaker.Character
		if not speakerChar or not getRoot(speakerChar) then return end
		for _, plr in pairs(Players:GetPlayers()) do
			if plr.Character and getRoot(plr.Character) then
				local raystart = getRoot(speakerChar).Position
				local rayend = getRoot(plr.Character).Position
				local raydirection = rayend - raystart
				local ray = Ray.new(raystart, raydirection)
				local rayhit = workspace:FindPartOnRayWithIgnoreList(ray, {speakerChar})
				if rayhit and rayhit:IsDescendantOf(plr.Character) then
					table.insert(returns,plr)
				end
			end
		end
		return returns
	end,
	["forcefield"] = function(speaker,args)
		local returns = {}
		for _, plr in pairs(Players:GetPlayers()) do
			if plr.Character and plr.Character:FindFirstChildOfClass("ForceField") then
				table.insert(returns,plr)
			end
		end
		return returns
	end,
	["holding"] = function(speaker,args)
		local returns = {}
		for _, plr in pairs(Players:GetPlayers()) do
			if plr.Character and plr.Character:FindFirstChildOfClass("Tool") then
				table.insert(returns,plr)
			end
		end
		return returns
	end,
	["holdingtaser"] = function(speaker,args)
		local returns = {}
		for _, plr in pairs(Players:GetPlayers()) do
			if plr.Character and plr.Character:FindFirstChild("Taser") then
				table.insert(returns,plr)
			end
		end
		return returns
	end
}

local all = {
	"pfastcar",
	"pgetcolor",
	"pjoinjobid",
	"pantibring",
	"joincommand",
	"nocollide",
	"unnocollide",
	"advertisePLC"
}

if not isPL then
	for i, cmd in pairs(PLC.Commands) do
		if not table.find(all, i) then
			PLC.Commands[i] = nil
		end
	end
	local info = "This game isn't prison life and only all game comands are added"
	PLC.Commands["PLCREADME"] = {
		["Description"] = info,
		["Aliases"] = {},
		["Function"] = function()
			notify("Notification", info)
		end
	}
else
	addcases["hostile"] = function(speaker,args)
		local returns = {}
		for _, plr in pairs(Players:GetPlayers()) do
			if isHostile(plr) then
				table.insert(returns,plr)
			end
		end
		return returns
	end
end

for name, case in pairs(addcases) do
	getfenv()["SpecialPlayerCases"][name] = case
end

local replace = ge().PLCdata.cmdreplace
local copy = {}
for n, d in pairs(PLC["Commands"]) do
	copy[n] = d
end
for name, data in pairs(copy) do
	if replace[name] then
		local func = data["Function"]
		local desc = data["Description"]
		local aliases = replace[name]["Aliases"]
		local newname = replace[name]["Name"]
		local display = data["ListName"] or newname
		PLC.Commands[name] = nil
		PLC.Commands[newname] = {
			["Description"] = desc,
			["Aliases"] = aliases,
			["Function"] = func,
			["ListName"] = display
		}
	end
end

if isPL then
	local hieght = -475
	local found = workspace:FindFirstChild("PLC - antifall")
	if found then
		found:Destroy()
	end
	local antifall = Instance.new("Model", workspace)
	antifall.Name = "PLC - antifall"
	local platform = Instance.new("Part", antifall)
	platform.Anchored = true
	platform.CFrame = CFrame.new(-128, 0 + hieght, 2048)
	platform.Size = Vector3.new(39, 1, 34)
	platform.Name = "platform"
	local stand = Instance.new("Part", antifall)
	stand.Anchored = true
	stand.CFrame = CFrame.new(-128, 2 + hieght, 2032)
	stand.Size = Vector3.new(2, 3, 2)
	stand.Name = "stand"
	local stand2 = Instance.new("WedgePart", antifall)
	stand2.Anchored = true
	stand2.CFrame = CFrame.new(-128, 4 + hieght, 2032) * CFrame.Angles(0, math.rad(180), 0)
	stand2.Size = Vector3.new(2, 1, 2)
	stand2.Name = "stand2"
	local button = Instance.new("Part", antifall)
	button.Anchored = true
	button.CFrame = CFrame.new(-128, 4.1 + hieght, 2032) * CFrame.Angles(math.rad(22.5), math.rad(-90), 0)
	button.Size = Vector3.new(1.6, 0.4, 1.6)
	button.BrickColor = BrickColor.new("Bright red")
	button.Name = "button"
	local UI = Instance.new("SurfaceGui", button)
	UI.Adornee = button
	UI.Face = "Top"
	local label = Instance.new("TextLabel", UI)
	label.Size = UDim2.new(1, 0, 1, 0)
	label.BackgroundTransparency = 1
	label.TextScaled = true
	label.Text = "Click to goto nexus"
	local CD = Instance.new("ClickDetector", button)
	CD.MouseClick:Connect(function()
		local char = Players.LocalPlayer.Character
		local root = getRoot(char) or char:FindFirstChildOfClass("BasePart")
		root.CFrame = CFrame.new(921, 100, 2374)
	end)
end

return PLC
