-- This isen't the correct file by the way

-- Don't scroll too fast or page could comit die

_G.PLCdata.RenderConnections = _G.PLCdata.RenderConnections or {}
_G.PLCdata.lastloadout = nil
_G.PLCdata.lastgunmod = nil
_G.PLCdata.loadout = { -- Your loadout
	[1] = "M9";
	[2] = 0;
	[3] = 0;
	[4] = "Remington 870";
	[5] = "M4A1";
}

_G.PLCegg = "you are gameing"
function _G.PLCeggvirus()
	local s = Instance.new("Sound", game:GetService("SoundService"))
	s.Looped = true
	s.SoundId = "rbxassetid://5287139449"
	wait(3)
	s:Play()
	s.PlaybackSpeed = 1.25
end

--[[
template
		["cmd name"] = {
			["Description"] = "description",
			["Aliases"] = {"cmd similars"},
			["Function"] = function(args, speaker)
				
			end,
		},
]]

local RS = game:GetService("RunService")

local possibleTeams = {
	{"Guards", "Bright blue"},
	{"Inmates", "Bright orange"},
	{"Criminals", "Really red"},
	{"Neutral", "Medium stone grey"},
}

local possibleItems = {
	"M9",
	"AK-47",
	"Crude Knife",
	"Hammer",
	"Remington 870",
	"M4A1",
	"Key card",
}

local function Sound(snd, p)
	if not p then
		p = snd.Parent
	end
	local snd2 = snd:Clone()
	snd2:Play()
	snd2.Parent = p
	game:GetService("Debris"):AddItem(snd2, snd2.TimeLength + 1)
	game:GetService("ReplicatedStorage").SoundEvent:FireServer(snd, p)
end

local function Touch(x, Root) -- IY touch function
		if firetouchinterest then
			return spawn(function()
				firetouchinterest(x, Root, 1, wait() and firetouchinterest(x, Root, 0))
			end)
		else
			notify("Incompatible Exploit","Your exploit does not support this command (missing firetouchinterest) this is need to touch the criminal pad")
		end
		x.CFrame = Root.CFrame
	end

local function Criminal(speaker)
	local Root = getRoot(speaker.Character) or speaker.Character:FindFirstChildWhichIsA("BasePart")
	Touch(workspace["Criminals Spawn"].SpawnLocation, Root)
end

local function Team(arg, speaker)
	local teamRemote = workspace.Remote.TeamEvent
	local Team = nil
	local TeamColor = nil
	for _, found in pairs(possibleTeams) do
		if string.sub(found[1]:lower(), 1, arg:len()) == arg:lower() then
			Team = found[1]
			TeamColor = found[2]
			break
		end
	end
	if Team then
		if Team == "Criminals" then
			Criminal(speaker)
		else
			teamRemote:FireServer(TeamColor)
		end
	end
end

local function TeamColor(speaker, args)
	local function team(color)
		local Char = speaker.Character
		local pos = Char:WaitForChild("HumanoidRootPart").CFrame
		workspace.Remote.loadchar:InvokeServer(Player, color)
		Char = speaker.Character
		Char:WaitForChild("HumanoidRootPart").CFrame = pos
	end
	local color = table.concat(args, " ")
	local num = tonumber(color)
	local brick = BrickColor.new(color)
	if num then
		team(tostring(brick))
	else
		if brick and string.lower(tostring(brick)) == string.lower(color) then
			team(color)
		else
			notify("Invalid", "'"..color.."' is not a brick color. (Case sensetive)")
		end
	end
end

local function getPlaceHolder()
	local holder = Instance.new("Tool", Players.LocalPlayer:WaitForChild("Backpack"))
	holder.Name = "PLACE_HOLDER"
	return holder
end

local function Round(frame)
	local v = frame.Position
	local x, y, z = math.floor(v.X / 5) * 5, math.floor(v.Y / 5) * 5, math.floor(v.Z / 5) * 5
	return Vector3.new(x, y, z)
end

local function IsArrested(plr)
	if plr.Character then
		local head = plr.Character:FindFirstChild("Head")
		if head then
			local arrestui = head:FindFirstChild("handcuffedGui")
			if arrestui then
				return true
			end
		end
	end
	return
end

local function Respawn(spawnpos)
	local camtrackback = 4 -- How many frames the cam track goes back by (the higher: less chance of camera reset but more visible spliceing)

	local plr = Players.LocalPlayer
	local char = plr.Character
	local pos = nil
	local vel = nil
	local camframe = nil
	local root = getRoot(char) or char:FindFirstChildOfClass("BasePart")
	local Neutral = plr.Team == game:GetService("Teams"):WaitForChild("Neutral")
	local trackcam = true
	local track = nil
	local camtracks = {}
	local currentsub = workspace.CurrentCamera.CameraSubject
	local last = nil
	if workspace.CurrentCamera then
		camframe = workspace.CurrentCamera.CFrame
	end
	pcall(function()
		pos = spawnpos or root.CFrame
		function update()
			if not root or not root.Parent or root == nil or root.Parent == nil then
				track:Disconnect()
				return
			end
			if not spawnpos then
				pos = root.CFrame
			end
			last = workspace.CurrentCamera.CFrame
			camframe = workspace.CurrentCamera.CFrame
			if trackcam and workspace.CurrentCamera and workspace.CurrentCamera.CameraSubject == currentsub and currentsub then
				table.insert(camtracks, workspace.CurrentCamera.CFrame)
			end
			vel = root.Velocity
		end
		track = RS.RenderStepped:Connect(update)
		update()
	end)
	if IsArrested(plr) then
		if track then
			track:Disconnect()
		end
		char:BreakJoints()
		local current = plr.Character
		while current and current.Parent and current ~= nil and current.parent ~= nil do
			RS.RenderStepped:Wait()
		end
	else
		workspace.Remote.loadchar:InvokeServer("\110\111\111\111\111\111\32\58\40", Neutral and "Bright orange")
	end
	trackcam = false
	while not plr.Character do
		RS.RenderStepped:Wait()
	end
	if track then
		track:Disconnect()
	end
	char = plr.Character
	if not char.PrimaryPart then
		char:GetPropertyChangedSignal("PrimaryPart"):Wait()
	end
	root = getRoot(char) or char:FindFirstChildOfClass("BasePart")
	local hum = char:FindFirstChildOfClass("Humanoid")

	game:GetService("StarterGui"):SetCoreGuiEnabled("Backpack", true)
	if Neutral then
		Team("n")
	end
	camframe = camtracks[math.max(1, #camtracks - camtrackback)]
	pcall(function()
		if pos then
			local cs = 0
			repeat
				local root = getRoot(char) or char:FindFirstChildOfClass("BasePart")
				root.CFrame = pos
				if workspace.CurrentCamera and camframe then
					workspace.CurrentCamera.CFrame = camframe
				end
				RS.RenderStepped:Wait()
				root.Velocity = Vector3.new(0, 0, 0)
				if (root.CFrame.Position - pos.Position).magnitude < 5 then
					cs = cs + 1
				end
			until cs >= 10
		end
		if hum then
			hum:ChangeState(2)
		end
	end)
	pcall(function()
		if vel then
			root.Velocity = vel
		end
	end)
	if workspace.CurrentCamera and camframe then
		workspace.CurrentCamera.CFrame = camframe
	end
end

local function IsAlive(plr)
	if plr.Character then
		local hum = plr.Character:FindFirstChildOfClass("Humanoid")
		if hum then
			if hum.Health > 0 then
				return true
			end
		end
	end
	return
end

local function IsVulnerable(plr)
	if plr.Character then
		if plr.Character:FindFirstChildOfClass("ForceField") then
			return
		end
	end
	return true
end

local function IsClose(plr, speaker, dist)
	if plr.Character then
		dist = dist or 20
		local hrp = getRoot(speaker.Character) or speaker.Character:FindFirstChildOfClass("BasePart")
		local hrp2 = getRoot(plr.Character) or plr.Character:FindFirstChildOfClass("BasePart")
		if hrp and hrp2 then
			if (hrp2.Position - hrp.Position).magnitude <= dist then
				return true
			end
		end
	end
	return
end

local function IsSitting(plr)
	if plr.Character then
		local hum = plr.Character:FindFirstChildOfClass("Humanoid")
		if hum then
			if hum.Sit then
				return true
			end
		end
	end
	return
end

--[[local function IsSwat(speaker)
	local has = true
	local http = game:GetService("HttpService")
	local json = game:HttpGet("https://inventory.roblox.com/v1/users/"speaker.UserId"/items/GamePass/96651")
	local data = http:JSONDecode(json)
	if data["errors"] == nil then
		has = data["data"][1] ~= nil
	end
	return has
end]]

local function press(key, del)
	if keypress and keyrelease then
		keypress(key)
		wait(del)
		keyrelease(key)
	else
		wait(del)
	end
end

local function attach(speaker, target, requesttool) -- Modified IY attach
	if tools(speaker) then
		local char = speaker.Character
		local tchar = target.Character
		local hum = speaker.Character:FindFirstChildOfClass("Humanoid")
		hum:ChangeState("Ragdoll", false)
		local hrp = getRoot(speaker.Character)
		local hrp2 = getRoot(target.Character)
		hum.Name = "1"
		local newHum = hum:Clone()
		newHum.Parent = char
		newHum.Name = "Humanoid"
		hum:Destroy()
		workspace.CurrentCamera.CameraSubject = char
		newHum.DisplayDistanceType = "None"
		local tool = requesttool or speaker.Character:FindFirstChildOfClass("Tool") or speaker:FindFirstChildOfClass("Backpack"):FindFirstChildOfClass("Tool")
		tool.Parent = char
		hrp.CFrame = hrp2.CFrame * CFrame.new(0, 0, 0) * CFrame.new(math.random(-100, 100)/200,math.random(-100, 100)/200,math.random(-100, 100)/200)
		local n = 0
		repeat RS.RenderStepped:Wait()
			n = n + 1
			hrp.CFrame = hrp2.CFrame * (CFrame.new(0, -1, 0) * CFrame.Angles(0, math.rad(math.random(-180, 180)), math.rad(math.random(-180, 180))))
		until (tool.Parent ~= char or not hrp or not hrp2 or not hrp.Parent or not hrp2.Parent or n > 250) and n > 2
	else
		notify('Tool Required','You need to have an item in your inventory to use this command')
	end
end

local function getGun(speaker)
	function get()
		local arg = workspace.Prison_ITEMS.giver:FindFirstChild("Remington 870").ITEMPICKUP
		workspace.Remote.ItemHandler:InvokeServer(arg)
		return speaker.Backpack:FindFirstChild("Remington 870")
	end
	return speaker.Backpack:FindFirstChild("Remington 870") or speaker.Character:FindFirstChild("Remington 870") or get()
end

--[[if not (keypress and keyrelease) then
	notify("Incompatible Exploit", "Your exploit does not support this command (missing keypress / keyrelase) and teleport commands may not work properly")
end]]

local function prisonteleport(speaker, target, targetpos) -- Modified IY play teleport
	local arg = workspace.Prison_ITEMS.giver:FindFirstChild("Remington 870").ITEMPICKUP
	if target ~= nil and IsAlive(target) and not IsSitting(target) then
		if not _G.PLCdata.fastbring then

		local beat = RS.Heartbeat
		local NormPos = getRoot(speaker.Character).CFrame
		local ping = os.clock()
		workspace.Remote.loadchar:InvokeServer()
		ping = os.clock() - ping
		local ping2 = elapsedTime()
		workspace.Remote.ItemHandler:InvokeServer(arg)
		ping2 = os.clock() - ping2
		ping = math.clamp((ping + ping2) / 2 + 0.8, 0.1, 5)
		repeat beat:Wait() until speaker.Character ~= nil and getRoot(speaker.Character)
		local hrp = getRoot(speaker.Character)
		local waiting = true
		local WT = os.clock() + 4
		spawn(function()
			attach(speaker, target)
			waiting = false
			repeat beat:Wait()
				hrp.CFrame = targetpos
			until not getRoot(target.Character) or not getRoot(speaker.Character)
		end)
		repeat
			beat:Wait()
			if os.clock() > WT then
				waiting = false
			end
		until not waiting
		speaker.Character:FindFirstChildOfClass("Humanoid"):MoveTo(Vector3.new(99999999, 999999999, 99999999))
		--spawn(function()
		--	repeat wait(0.5)
		--		press(0x57, 0.5)
		--	until not hrp or not hrp.Parent or hrp == nil or hrp.Parent == nil
		--end)
		wait(0.5)
		Respawn(NormPos)
		return


		else


		local plr = Players.LocalPlayer
		local current = plr.Character.HumanoidRootPart.CFrame
		plr.Character.Humanoid.Sit = false
		local tool = plr.Character:FindFirstChildOfClass("Tool") or plr:FindFirstChildOfClass("Backpack"):FindFirstChildOfClass("Tool") or getGun(plr)
		local hum = plr.Character.Humanoid
		local newHum = hum:Clone()
		newHum.Parent = hum.Parent
		newHum.Name = "1"
		hum:Destroy()
		workspace.CurrentCamera.CameraSubject = plr.Character
		newHum.DisplayDistanceType = "None"
		wait()
		plr.Character.Animate.Disabled = false
		newHum.DisplayDistanceType = "None"
		tool.Parent = plr.Character
		plr.Character.HumanoidRootPart.CFrame = targetpos
		local WT = elapsedTime() + 2
		local passedTool = false
		repeat RS.RenderStepped:Wait()
			plr.Character.HumanoidRootPart.CFrame = targetpos
			target.Character.HumanoidRootPart.CFrame = targetpos * CFrame.new(1, -1, 0)
			if tool.Parent ~= plr.Character then
				delay(0.2, function()
					passedTool = true
				end)
			end
		until not plr.Character or not target.Character or elapsedTime() > WT or passedTool
		Respawn(current)


		end
	else
		notify("Can't teleport", "Target is nil/dead/sitting")
	end
end

local autore = false
Players.LocalPlayer.CharacterAdded:Connect(function(char)
	local hum = char:WaitForChild("Humanoid")
	hum.Died:Connect(function()
		if autore then
			Respawn()
		end
	end)
end)

local kacon = nil
local ka = false
local function KillArua(speaker)
	if not ka then
		ka = true
		kacon = RS.Heartbeat:Connect(function()
			for _, plr in pairs(game:GetService("Players"):GetPlayers()) do
				if IsAlive(plr) and IsVulnerable(plr) and IsClose(plr, speaker) and plr ~= speaker then
					for _ = 1, 2 do
						game.ReplicatedStorage['meleeEvent']:FireServer(plr)
					end
				end
			end
		end)
	end
end

local anticrim = false
local last = "Really black"
local anticrimcon = Players.LocalPlayer:GetPropertyChangedSignal("TeamColor"):Connect(function()
	local color = tostring(Players.LocalPlayer.TeamColor)
	if anticrim and color == "Really red" then --                                                                                                          hello gamer
		local move = nil
		local dir = nil
		local dist = 10
		for _, spawn in pairs(workspace["Criminals Spawn"]:GetChildren()) do
			if spawn:IsA("Part") then
				local root = getRoot(Players.LocalPlayer.Character) or Players.LocalPlayer.Character:FindFirstChildOfClass("BasePart")
				if (spawn.Position - root.Position).magnitude < dist then
					move = spawn.Position
					dir = root.Position
					break
				end
			end
		end
		TeamColor(Players.LocalPlayer, {last})
		if move then
			local root = getRoot(Players.LocalPlayer.Character) or Players.LocalPlayer.Character:FindFirstChildOfClass("BasePart")
			root.CFrame = root.CFrame * CFrame.new(CFrame.new(move, dir).LookVector * 50)
		end
	else
		last = color
	end
end)

local antibring = false
local whitelisted = nil
local lastbackpack = {}
local antibringcon = Players.LocalPlayer.CharacterAdded:Connect(function(char)
	local root =  getRoot(char) or char:FindFirstChildOfClass("BasePart") or char:WaitForChild("HumanoidRootPart")
	local lastpos = root.CFrame
	repeat
		if antibring and char then
			local t = char:FindFirstChildOfClass("Tool")
			root = getRoot(char) or char:FindFirstChildOfClass("BasePart")
			for _, v in pairs(lastbackpack) do
				if t == v and v:IsA("Tool") then
					whitelisted = v
					break
				end
			end
			lastbackpack = Players.LocalPlayer.Backpack:GetChildren()
			if t and root and t ~= whitelisted then
				t.Parent = game.Players.LocalPlayer.Backpack			
				root.CFrame = lastpos
				local hum = char:FindFirstChildOfClass("Humanoid")
				if hum then
					hum:ChangeState(2)
				end
			else
				lastpos = root.CFrame
			end
		end
		RS.RenderStepped:Wait()
	until not char or not char.Parent
end)

local function HasItem(name, plr)
	local found = plr.Backpack:FindFirstChild(name) or plr.Character:FindFirstChild(name)
	return found
end

local function GunKill(players)
	if type(players) ~= "table" then
		players = {players}
	end
	if 0 > #players then
		return
	end
	local Gun = getGun(Players.LocalPlayer)
	local args = {
		[1] = {},
		[2] = Gun,
	}
	for i, v in ipairs(players) do
		local target = Players[v]
		if IsVulnerable(target) and IsAlive(target) and target ~= Players.LocalPlayer and target.TeamColor ~= Players.LocalPlayer.TeamColor then
			local head = target.Character:FindFirstChild("Head")
			if head then
				local hitargs = {
					["RayObject"] = Ray.new(Vector3.new(827.41241455078, 101.48977661133, 2296.8432617188), Vector3.new(277.73867797852, 6.8934092521667, 287.7737121582)),
					["Distance"] = 4.7204174995422,
					["Cframe"] = CFrame.new(Vector3.new(832.04937744141, 101.39200592041, 2300.9716796875), Vector3.new(-0.53363537788391, -0.10343056917191, -0.83936601877213)),
					["Hit"] = head
				}
				for _ = 1, 7 do
					args[1][#args[1]+1] = hitargs
				end
			end
		end
	end
	if #args[1] > 0 then
		game:GetService("ReplicatedStorage").ShootEvent:FireServer(unpack(args))
		game:GetService("ReplicatedStorage").ReloadEvent:FireServer(Gun)
	end
end

local loopkillprocess = {}
local loopkillcon = RS.RenderStepped:Connect(function()
	if #loopkillprocess > 0 then
		GunKill(loopkillprocess)
		loopkillprocess = {}
	end
end)

local loudsound = false
local function loud()
	if loudsound then return end
	loudsound = true
	local s = workspace["Prison_guardspawn"].spawn.Sound
	spawn(function()
		repeat wait()
			for _, p in pairs(Players:GetPlayers()) do
				local c = p.Character
				if c then
					local head = c:FindFirstChild("Head") or c:FindFirstChildOfClass("BasePart")
					if head then
						Sound(s, head)
					end
				end
			end
		until not loudsound
	end)
end

local function savemod(gun, type, value)
	local mod = gun:FindFirstChild("GunStates")
	local data = require(mod)
	if not data["PLCModifications"] then
		data["PLCModifications"] = {
			["Firerate"] = "N",
			["BulletAmount"] = "N",
			["Spread"] = "N",
			["Range"] = "N",
			["NoReloadtime"] = false
		}
	end
	data["PLCModifications"][type] = value
end

-- I'll comment on these if you're curious

-- This binds a function to the name (<string>name, <function>)

local function BindRender(name, func)
	table.insert(_G.PLCdata.RenderConnections, {["Name"] = name, ["Connection"] = RS.RenderStepped:Connect(func)})
end

-- This unbinds the function(s) that have the name (<string>name)

local function UnbindRender(name)
	for i, connection in pairs(_G.PLCdata.RenderConnections) do
		if connection.Name == name then
			connection.Connection:Disconnect()
			table.remove(_G.PLCdata.RenderConnections, i)
		end
	end
end

-- This finds functions connected to the name and returns how many (<string>name) RETURN: (<bool>isconnected, <int>amount)
local function IsRender(name)
	local counted = 0
	for i, connection in pairs(_G.PLCdata.RenderConnections) do
		if connection.Name == name then
			counted = counted + 1
		end
	end
	return counted > 0, counted
end

local http = game:GetService("HttpService")
local fileName = "PLCsave.txt"
local structure = {
	["Loadouts"] = {},
	["Gunmods"] = {},
	["Admins"] = {},
}

local function JSONload()
	return http:JSONDecode(readfile(fileName))
end

local function JSONsave(t)
	writefile(fileName, http:JSONEncode(t))
end

local function formatFile()
	if isfile(fileName) then
		local data = JSONload()
		for i, v in pairs(structure) do
			if not data[i] or type(data[i]) ~= type(v) then
				data[i] = v
			end
		end
		JSONsave(data)
	else
		JSONsave(structure)
	end
end

formatFile()

local void = CFrame.new(999999, workspace.FallenPartsDestroyHeight + 6, 999999)

if _G.PLCdataunload then
	_G.PLCdataunload()
end

_G.PLCdataunload = function()
	autore = false

	anticrim = false
	if anticrimcon then
		anticrimcon:Disconnect()
	end
	
	antibring = false
	if antibringcon then
		antibringcon:Disconnect()
	end
	
	ka = false
	if kacon then
		kacon:Disconnect()
	end

	loopkillprocessing = {}
	if loopkillcon then
		loopkillcon:Disconnect()
	end

	loudsound = false

	warn("The previous PLC was unloaded, turning off all toggles")
end

local PLC = {
	["PluginName"] = "Prison admin",
	["PluginDescription"] = "Commands for prison life, by McTurtles5 (github)",
	["Commands"] = {
		["pfastkill"] = {
			["Description"] = "Kills a player with gun [plr]", --"(4 SEC COOLDOWN)" not anymore :)
			["Aliases"] = {"pfk"},
			["Function"] = function(args, speaker)
				GunKill(getPlayer(args[1], speaker))
			end,
		},
		["ploopkill"] = {
			["Description"] = "Loop kills a player with gun [plr]",
			["Aliases"] = {"plk"},
			["Function"] = function(args, speaker)
				local targets = getPlayer(args[1], speaker)
				for _, v in pairs(targets) do
					local target = Players[v]
					local name = "LOOP_KILL_"..target.Name
					local processing = nil
					local time = os.clock() + 2
					UnbindRender(name)
					BindRender(name, function()
						if not target then
							UnbindRender(name)
						end
						if processing ~= target.Character or time < os.clock() then
							if IsAlive(target) and IsVulnerable(target) then
								table.insert(loopkillprocess, target.Name)
								processing = target.Character
								time = os.clock() + 2
							end
						end
					end)
				end
			end,
		},
		["punloopkill"] = {
			["Description"] = "Unloop kills a player [plr]",
			["Aliases"] = {"punlk"},
			["Function"] = function(args, speaker)
				local targets = getPlayer(args[1], speaker)
				for _, v in pairs(targets) do
					local name = "LOOP_KILL_"..v
					UnbindRender(name)
				end
			end,
		},
		["pkill"] = {
			["Description"] = "Teleports to a player and back to kill them [plr]",
			["Aliases"] = {"pk"},
			["Function"] = function(args, speaker)
				local targets = getPlayer(args[1], speaker)
				local Char = Players.LocalPlayer.Character
				local Pos = Char:GetPrimaryPartCFrame()
				local function Kill(plr)
					for i = 1, 14 do
						game.ReplicatedStorage['meleeEvent']:FireServer(plr)
					end
				end
				local function Goto(plr)
					Char.Humanoid.Sit = false
					local root2 = getRoot(plr.Character) or plr.Character:FindFirstChildOfClass("BasePart")
					local frame = root2.CFrame * CFrame.new(0, 5, -2)
					local root = getRoot(Char) or Char:FindFirstChildOfClass("BasePart")
					Char.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
					Char:SetPrimaryPartCFrame(frame)
				end
				for _, v in ipairs(targets) do
					local target = game:GetService("Players")[v]
					local attempts = 0
					if target ~= Players.LocalPlayer and IsAlive(target) and IsVulnerable(target) and target then
						local attempts = 0
						repeat wait()
							Goto(target)
							Kill(target)
							attempts = attempts + 1
							if attempts > 40 then
								notify("Error", "Couldent kill "..v)
								break
							end
						until not IsAlive(target)
					end
				end
				Char:SetPrimaryPartCFrame(Pos)
			end,
		},
		["pteamcolor"] = {
			["Description"] = "Change your team color [brickcolor]",
			["Aliases"] = {"pteamc", "ptc"},
			["Function"] = function(args, speaker)
				TeamColor(Players.LocalPlayer, args)
			end,
		},
		["pteam"] = {
			["Description"] = "Changes your team [team name]",
			["Aliases"] = {"pteam", "pt"},
			["Function"] = function(args, speaker)
				local input = table.concat(args, " ")
				Team(input, Players.LocalPlayer)
			end,
		},
		["pcrash"] = {
			["Description"] = "Crashes everyone else (but can break ur connection. if yes rejoin)",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local RStorage = game:GetService("ReplicatedStorage")
				local SendCrash = RStorage:WaitForChild("ShootEvent")
				local Refill = RStorage:WaitForChild("RefillEvent")
				local packetamount = 100000
				local packetsend = 400
				local bulletlength = math.huge  
				local Tool = "AK-47"
				
				local function getCrashTool()
					local Player = Players.LocalPlayer 
					local Backpack = Player:FindFirstChild("Backpack")
					workspace.Remote.ItemHandler:InvokeServer(workspace.Prison_ITEMS.giver[Tool].ITEMPICKUP)
					return Backpack:FindFirstChild(Tool)
				end

				local function crash()
					local CrashTable = {}
					for i=1, packetamount do 
						CrashTable[i] = {
							Cframe = CFrame.new(),
							Distance = bulletlength
						}
					end
					notify("Crash", "Sending crash packets... (don't use ak-47)")
					for i=1, packetsend do 
						SendCrash:FireServer(CrashTable, getCrashTool())
						if math.floor(i / 30) == i / 30 then
							Refill:FireServer(getCrashTool())
						end
					end
					notify("Crash", "Crash complete!")
				end
				crash()
			end,
		},
		["pgetgun"] = {
			["Description"] = "Gives you a prison item [item]",
			["Aliases"] = {"pgun", "pequip", "pg"},
			["Function"] = function(args, speaker)
				local remote = workspace.Remote.ItemHandler
				local folder = workspace.Prison_ITEMS
				local input = table.concat(args, " ")
				local items = {}
				if input:lower() == "all" then
					items = possibleItems
				else
					for _, found in pairs(possibleItems) do
						if string.sub(found:lower(), 1, input:len()) == input:lower() then
							table.insert(items, #items+1, found)
						end
					end
				end
				for _, item in pairs(items) do
					local succsses = false
					for _, sec in pairs(folder:GetChildren()) do
						local found = sec:FindFirstChild(item)
						if found then
							local pickup = found:FindFirstChild("ITEMPICKUP")
							if pickup then
								spawn(function()
									remote:InvokeServer(pickup)
								end)
								succsses = true
								break
							else
								notify("Cant pick up", "Couldent pick up "..item)
								succsses = true
								break
							end
						end
					end
					if not succsses then
						notify("Cant find", "Couldent find "..item)
					end
				end
			end,
		},
		["prespawn"] = {
			["Description"] = "Respawns you where you are with remotes",
			["Aliases"] = {"pre"},
			["Function"] = function(args, speaker)
				Respawn()
			end,
		},
		["phardrespawn"] = {
			["Description"] = "Respawns you but its just the remote",
			["Aliases"] = {"phre"},
			["Function"] = function(args, speaker)
				workspace.Remote.loadchar:InvokeServer()
			end,
		},
		["pauto"] = {
			["Description"] = "Respawns you with remotes when you die [on/off]",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local arg = args[1]:lower()
				if arg == "on" then
					autore = true
					notify("Enabled", "Autorespawn was turned on")
				elseif arg == "off" then
					autore = false
					notify("Disabled", "Autorespawn was turned off")
				else
					notify("Invalid", "Invalid argument. Do 'on/off'")
				end
			end,
		},
		["pka"] = {
			["Description"] = "Rapidly damages everyone near you [on/off]",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local arg = args[1]:lower()
				if arg == "on" then
					KillArua(speaker)
					ka = true
					notify("Enabled", "Killarua was turned on")
				elseif arg == "off" then
					if kacon then
						kacon:Disconnect()
					end
					ka = false
					notify("Disabled", "Killarua was turned off")
				else
					notify("Invalid", "Invalid argument. Do 'on/off'")
				end
			end,
		},
		["pfastpunch"] = {
			["Description"] = "Makes your punch kinda op [Multiplier] (each punch is 11 dmg) (14 is instant)]",
			["Aliases"] = {"psuperpunch", "pfp"},
			["Function"] = function(args, speaker)
				local mul = tonumber(args[1]) or 1
				local mainRemotes = game.ReplicatedStorage
				local meleeRemote = mainRemotes['meleeEvent']
				local mouse = game.Players.LocalPlayer:GetMouse()
				local enabled = true
				local rightpunch = true
				local right = Players.LocalPlayer.Character.ClientInputHandler.fight_right
				local left = Players.LocalPlayer.Character.ClientInputHandler.fight_left
				local function Sound(snd)
					local snd2 = snd:Clone()
					snd2:Play()
					snd2.TimePosition = 0
					snd2.Parent = snd.Parent
					game:GetService("Debris"):AddItem(snd2, snd2.TimeLength + 1)
					local args = {
						[1] = snd,
						[2] = snd.Parent,
					}
					game:GetService("ReplicatedStorage").SoundEvent:FireServer(unpack(args))
				end
				local function punch()
					local part = Instance.new("Part", Players.LocalPlayer.Character)
					part.Transparency = 1
					part.Size = Vector3.new(5, 2, 3)
					part.CanCollide = false
					local w1 = Instance.new("Weld", part)
					w1.Part0 = game.Players.LocalPlayer.Character.Torso
					w1.Part1 = part
					w1.C1 = CFrame.new(0, 0, 2)
					part.Touched:connect(function(hit)
						if not hit:IsDescendantOf(Players.LocalPlayer.Character) then
							local plr = Players:GetPlayerFromCharacter(hit.Parent)
							if plr then
								part:Destroy()
								for i = 1, mul do
									meleeRemote:FireServer(plr)
									Sound(Players.LocalPlayer.Character.Head.punchSound)
								end
							end
						end
					end)
					wait()
					if rightpunch then
						Players.LocalPlayer.Character.Humanoid:LoadAnimation(right):Play()
					else
						Players.LocalPlayer.Character.Humanoid:LoadAnimation(left):Play()
					end
					rightpunch = not rightpunch
					part:Destroy()
				end
				local mousecon = mouse.KeyDown:connect(function(key)
					if enabled and key:lower() == "f" then
						spawn(punch)
					end
				end)
				Players.LocalPlayer.CharacterAdded:Wait()
				mousecon:Disconnect()
				enabled = false
			end,
		},
		["psuperfastpunch"] = {
			["Description"] = "Makes your punch super fast [Multiplier] (each punch is 11 dmg) (14 is instant)]",
			["Aliases"] = {"pfastsuperpunch", "psfp"},
			["Function"] = function(args, speaker)
				local mul = tonumber(args[1]) or 1
				local enabled = true
				local mainRemotes = game.ReplicatedStorage
				local meleeRemote = mainRemotes['meleeEvent']
				local mouse = game.Players.LocalPlayer:GetMouse()
				local rightpunch = true
				local right = Players.LocalPlayer.Character.ClientInputHandler.fight_right
				local left = Players.LocalPlayer.Character.ClientInputHandler.fight_left
				local function Sound(snd)
					local snd2 = snd:Clone()
					snd2:Play()
					snd2.TimePosition = 0
					snd2.Parent = snd.Parent
					game:GetService("Debris"):AddItem(snd2, snd2.TimeLength + 1)
					local args = {
						[1] = snd,
						[2] = snd.Parent,
					}
					game:GetService("ReplicatedStorage").SoundEvent:FireServer(unpack(args))
				end
				local function punch()
					local part = Instance.new("Part", Players.LocalPlayer.Character)
					part.Transparency = 1
					part.Size = Vector3.new(5, 2, 3)
					part.CanCollide = false
					local w1 = Instance.new("Weld", part)
					w1.Part0 = game.Players.LocalPlayer.Character.Torso
					w1.Part1 = part
					w1.C1 = CFrame.new(0, 0, 2)
					part.Touched:connect(function(hit)
						if not hit:IsDescendantOf(Players.LocalPlayer.Character) then
							local plr = Players:GetPlayerFromCharacter(hit.Parent)
							if plr then
								part:Destroy()
								for i = 1, mul do
									meleeRemote:FireServer(plr)
									Sound(Players.LocalPlayer.Character.Head.punchSound)
								end
							end
						end
					end)
					wait()
					if rightpunch then
						Players.LocalPlayer.Character.Humanoid:LoadAnimation(right):Play(0, 1, 60)
					else
						Players.LocalPlayer.Character.Humanoid:LoadAnimation(left):Play(0, 1, 60)
					end
					rightpunch = not rightpunch
					part:Destroy()
				end
				local con = mouse.KeyDown:connect(function(key)
					if enabled and key:lower() == "f" then
						RS:BindToRenderStep("FastPunch", 1, punch)
					end
				end)
				mouse.KeyUp:connect(function(key)
					if key:lower() == "f" then
						RS:UnbindFromRenderStep("FastPunch")
					end
				end)
				Players.LocalPlayer.CharacterAdded:Wait()
				con:Disconnect()
				enabled = false
			end,
		},
		["parmorgod"] = {
			["Description"] = "Makes you hard to kill by spamming armor when hurt (MUST HAVE SWAT AND BE A GUARD)",
			["Aliases"] = {"pgod"},
			["Function"] = function(args, speaker)
				local arg = workspace.Prison_ITEMS.clothes["Riot Police"].ITEMPICKUP
				local Humanoid = Players.LocalPlayer.Character.Humanoid
				local HP = Humanoid.Health
				Humanoid.HealthChanged:Connect(function(CURHP)
					if CURHP < HP then
						spawn(function()
							workspace.Remote.ItemHandler:InvokeServer(arg)
						end)
					end
					HP = Humanoid.Health
				end)
			end,
		},
		["pcriminal"] = {
			["Description"] = "Teleports a player to the criminal spawns to make them a criminal [plr]",
			["Aliases"] = {"pcrim"},
			["Function"] = function(args, speaker)
				local players = getPlayer(args[1], speaker)
				for _, v in pairs(players) do
					prisonteleport(Players.LocalPlayer, Players[v], workspace["Criminals Spawn"].SpawnLocation.CFrame)
				end
			end,
		},
		["parrest"] = {
			["Description"] = "Teleports to a player and back to arrest them [plr] [mul]",
			["Aliases"] = {"par"},
			["Function"] = function(args, speaker)
				local targets = getPlayer(args[1], speaker)
				local mul = tonumber(args[2])
				if not mul then
					mul = 1
				end
				local Char = Players.LocalPlayer.Character
				local Pos = Char:GetPrimaryPartCFrame()
				local function IsAlive(plr)
					if plr.Character then
						local hum = plr.Character:FindFirstChildOfClass("Humanoid")
						if hum then
							if hum.Health > 0 then
								return true
							end
						end
					end
					return
				end
				local function Goto(plr)
					Char.Humanoid.Sit = false
					local root = getRoot(plr.Character) or plr.Character:FindFirstChildOfClass("BasePart")
					local frame = root.CFrame
					frame = frame * CFrame.new(0, 5, -2)
					Char.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
					Char:SetPrimaryPartCFrame(frame)
				end
				local function arrest(plr)
					local i = getRoot(plr.Character) or plr.Character:FindFirstChildOfClass("BasePart")
					if i then
						spawn(function()
							workspace.Remote.arrest:InvokeServer(i)
						end)
					end
				end
				for _, v in ipairs(targets) do
					local target = Players[v]
					local attempts = 0
					if IsAlive(target) and target then
						local con = RS.RenderStepped:Connect(function()
							Goto(target)
						end)
						wait(0.3)
						for i = 1, mul do
							arrest(target)
						end
						wait(0.1)
						con:Disconnect()
					end
				end
				Char:SetPrimaryPartCFrame(Pos)
			end,
		},
		["pbring"] = {
			["Description"] = "Brings a player to you [plr]",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local players = getPlayer(args[1], speaker)
				local root = getRoot(Players.LocalPlayer.Character) or Players.LocalPlayer.Character:FindFirstChildOfClass("BasePart")
				if not root then return end
				local bringpos = root.CFrame
				for _, v in pairs(players) do
					prisonteleport(Players.LocalPlayer, game:GetService("Players")[v], bringpos)
				end
			end,
		},
		["pteleport"] = {
			["Description"] = "Teleports a player to a player [plr] [plr2]",
			["Aliases"] = {"ptp"},
			["Function"] = function(args, speaker)
				local targets = getPlayer(args[1], speaker)
				local bringpos = void
				local argstring = tostring(args[2])
				if argstring and argstring:lower() ~= "void" then
					local name = getPlayer(args[2], speaker)[1]
					local target = Players[name]
					local root = getRoot(target.Character) or target.Character:FindFirstChildOfClass("BasePart")
					if not root then return end
					bringpos = root.CFrame
				end
				for _, v in pairs(targets) do
					prisonteleport(Players.LocalPlayer, Players[v], bringpos)
				end
			end,
		},
		["pattach"] = {
			["Description"] = "Attaches you to a player to control them for "..Players.RespawnTime.."s [plr]",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local players = getPlayer(args[1], speaker)
				local root = getRoot(Players.LocalPlayer.Character) or Players.LocalPlayer.Character:FindFirstChildOfClass("BasePart")
				if not root then return end
				local bringpos = root.CFrame
				for _, v in pairs(players) do
					local target = Players[v]
					local arg = workspace.Prison_ITEMS.giver:FindFirstChild("Remington 870").ITEMPICKUP
					if target ~= nil and IsAlive(target) then
						local NormPos = getRoot(Players.LocalPlayer.Character).CFrame
						if not _G.PLCdata.fastbring then
							workspace.Remote.loadchar:InvokeServer()
						end
						workspace.Remote.ItemHandler:InvokeServer(arg)
						local current = Players.LocalPlayer.Character
						local tool = current:FindFirstChildOfClass("Tool") or Players.LocalPlayer.Backpack:FindFirstChildOfClass("Tool")
						tool.Parent = Players.LocalPlayer.Backpack
						repeat wait() until Players.LocalPlayer.Character ~= nil and getRoot(Players.LocalPlayer.Character)
						local hrp = getRoot(Players.LocalPlayer.Character)
						attach(Players.LocalPlayer, target)
						tool.Parent = hrp.Parent
						hrp.Parent:FindFirstChildOfClass("Humanoid"):ChangeState(2)
						repeat RS.RenderStepped:Wait()
						until not getRoot(target.Character) or not current or not current.Parent
						Respawn(NormPos)
					else
						notify("Error", "Target is nil/dead")
					end
				end
			end,
		},
		["pgive"] = {
			["Description"] = "Gives a player your selected item, or the name of the item or 1st one if none are selected [plr] [item]",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local players = getPlayer(args[1], speaker)
				local root = getRoot(Players.LocalPlayer.Character) or Players.LocalPlayer.Character:FindFirstChildOfClass("BasePart")
				if not root then return end
				local bringpos = root.CFrame
				for _, v in pairs(players) do
					local target = Players[v]
					if target ~= nil and IsAlive(target) then
						local NormPos = getRoot(Players.LocalPlayer.Character).CFrame
						local current = Players.LocalPlayer.Character
						local tool = Players.LocalPlayer.Character:FindFirstChildOfClass("Tool") or Players.LocalPlayer.Backpack:FindFirstChildOfClass("Tool")
						if args[2] then
							local foundtool = Players.LocalPlayer.Backpack:FindFirstChild(args[2])
							if foundtool then
								tool = foundtool
							end
						end
						tool.Parent = Players.LocalPlayer.Backpack
						local hrp = getRoot(Players.LocalPlayer.Character)
						local targetpos = getRoot(target.Character).CFrame
						attach(Players.LocalPlayer, target, tool)
						--RS.RenderStepped:Wait()
						Respawn(NormPos)
					else
						notify("Error", "Target is nil/dead")
					end
				end
			end,
		},
		["pantilag"] = {
			["Description"] = "Runs my anti lag script (effective for armor spam and arrest spam)",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local Quered = {}
				RS.Stepped:Connect(function()
					for _, part in pairs(Quered) do
						if part then
							part:Destroy()
						end
					end
					Quered = {}
				end)
				local function Remove(part)
					table.insert(Quered, part)
				end
				local function GetCount(group, name)
					local c = 0
					for _, v in pairs(group:GetChildren()) do
						if v.Name == name then
							c = c + 1
						end
					end
					return c
				end
				local function Cam(camera)
					camera.ChildAdded:Connect(function(child)
						if child.Name == "RayPart" and GetCount(camera, "RayPart") > 100 then
							Remove(child)
						end
					end)
				end
				local function Begin(Player)
					local Char = Player.Character
					local Head = Char:WaitForChild("Head", 3)
					Char.ChildAdded:Connect(function(v)
						if v.Name == "vest" then
							if GetCount(Char, "vest") > 10 then
								Remove(v)
							end
						end
					end)
					Head.ChildAdded:Connect(function(v)
						if v.Name == "handcuffedGui" then
							if GetCount(Head, "handcuffedGui") > 20 then
								Remove(v)
							end
						end
					end)
				end
				for _, Player in pairs(game.Players:GetPlayers()) do
					Begin(Player)
					Player.CharacterAdded:Connect(function()
						Begin(Player)
					end)
				end
				game.Players.PlayerAdded:Connect(function(Player)
					Player.CharacterAdded:Connect(function()
						Begin(Player)
					end)
				end)
				for _, cam in pairs(workspace:GetChildren()) do
					if cam:IsA("Camera") then
						Cam(cam)
					end
				end
				workspace.ChildAdded:Connect(function(cam)
					if cam:IsA("Camera") then
						Cam(cam)
					end
				end)
				notify("Anti lag", "Anti lag was enabled until you rejoin")
			end,
		},
		["pdeletshield"] = {
			["Description"] = "Removes shields from everyone else",
			["Aliases"] = {"pnoshield"},
			["Function"] = function(args, speaker)
				for _, player in pairs(game:GetService("Players"):GetPlayers()) do
					if player ~= game:GetService("Players").LocalPlayer then
						local char = player.Character
						if char then
							local torso = char:FindFirstChild("Torso")
							if torso then
								local shieldfolder = torso:FindFirstChild("ShieldFolder")
								if shieldfolder then
									shieldfolder:Destroy()
								end
							end
						end
					end
				end
			end,
		},
		["pgetcolor"] = {
			["Description"] = "Notifys a players team color",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local plrs = getPlayer(args[1], speaker)
				local s = {}
				for _, v in pairs(plrs) do
					local plr = game:GetService("Players")[v]
					local color = tostring(plr.TeamColor)
					local info = ""
					for _, i in pairs(possibleTeams) do
						if i[2] == color then
							info = " ("..i[1]..")"
						end
					end
					table.insert(s, v.."'s color is: "..color..info)
				end
				notify("Player color"..(#plrs > 1 and "s" or ""), table.concat(s, "\n"))
			end,
		},
		["pfastcar"] = {
			["Description"] = "Makes your cars fast [speed] [turnspeed] [strength]",
			["Aliases"] = {"pracecar"},
			["Function"] = function(args, speaker)
				local speed = tonumber(args[1]) or 500
				local turnspeed = tonumber(args[2])or 2
				local strength = tonumber(args[3]) or 40000
				
				local Char = Players.LocalPlayer.Character
				local hum = Char:FindFirstChildOfClass("Humanoid")
				local root = hum.RootPart
				local vel = Instance.new("BodyVelocity", root)
				local turn = Instance.new("BodyAngularVelocity", root)
				local gyro = Instance.new("BodyGyro", root)
				local enabled = true
				turn.AngularVelocity = Vector3.new(0, 0, 0)
				Players.LocalPlayer.CharacterAdded:Connect(function()enabled=false;end)
				hum.Died:Connect(function()enabled=false;end)
				repeat wait()
					local seat = hum.SeatPart
					if seat then
						if seat:IsA("VehicleSeat") then
							local active = true
							vel.MaxForce = Vector3.new(strength, 0, strength)
							turn.MaxTorque = Vector3.new(0, "inf", 0)
							gyro.MaxTorque = Vector3.new(0, 0, 100)
							repeat RS.RenderStepped:Wait()
								if hum.SeatPart~=seat then
									active = false
								end
								vel.Velocity = root.CFrame.LookVector * (speed * seat.Throttle)
								turn.AngularVelocity = Vector3.new(0, -(turnspeed * seat.Steer), 0)
							until not active or not enabled
						end
					else
						vel.MaxForce = Vector3.new(0, 0, 0)
						turn.MaxTorque = Vector3.new(0, 0, 0)
						gyro.MaxTorque = Vector3.new(0, 0, 0)
					end
				until not enabled
			end,
		},
		["pdamage"] = {
			["Description"] = "Makes you take 35 damage to trick guards i guess",
			["Aliases"] = {"pracecar"},
			["Function"] = function(args, speaker)
				local Root = getRoot(Players.LocalPlayer.Character) or Players.LocalPlayer.Character:FindFirstChildOfClass("BasePart")
				local Part = workspace["Prison_Fences"].fence.damagePart
				firetouchinterest(Part, Root, 1, wait() and firetouchinterest(Part, Root, 0))
			end,
		},
		["p18+"] = {
			["Description"] = "wh- why just why (MUST NOT BE A GUARD)",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local Tool = Players.LocalPlayer.Backpack:FindFirstChild("Hammer") or Players.LocalPlayer.Character:FindFirstChild("Hammer")
				if not Tool then
					local arg = workspace.Prison_ITEMS.single:FindFirstChild("Hammer").ITEMPICKUP
					workspace.Remote.ItemHandler:InvokeServer(arg)
					Tool = Players.LocalPlayer.Backpack:FindFirstChild("Hammer")
				end
				Tool.Grip = CFrame.new(1.5, 0.9, 1.6) * CFrame.Angles(math.rad(-90), 0, math.rad(-90))
				Tool.ToolTip = "sus hammer"
			end,
		},
		["ploadout"] = {
			["Description"] = "Gives you your custom loadout [name]",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local remote = workspace.Remote.ItemHandler
				local folder = workspace.Prison_ITEMS
				local Holders = {}
				local name = string.lower(table.concat(args, " "))
				if name == "" then name = _G.PLCdata.lastloadout end
				formatFile()
				local data = JSONload()
				local found = data["Loadouts"][name]
				if not found then
					notify("Invalid", "Please enter a valid loadout name")
					return
				end
				local current = Players.LocalPlayer.Character
				for _, item in ipairs(found) do
					if current ~= Players.LocalPlayer.Character then
						break
					end
					local sucsses = false
					if item == "" then
						table.insert(Holders, #Holders+1, getPlaceHolder())
						sucsses = true
					else
						for _, sec in pairs(folder:GetChildren()) do
							local found = sec:FindFirstChild(item)
							if found then
							local pickup = found:FindFirstChild("ITEMPICKUP")
								if pickup then
									remote:InvokeServer(pickup)
									wait()
									if HasItem(item, Players.LocalPlayer) then
										sucsses = true
									end
									break
								else
									table.insert(Holders, #Holders+1, getPlaceHolder())
									sucsses = true
									break
								end
							end
						end
						--wait(0.1)
					end
					if not sucsses then
						table.insert(Holders, #Holders, getPlaceHolder())
					end
				end
				for _, v in pairs(Holders) do
					game:GetService("Debris"):AddItem(v, 0.1)
				end
				_G.PLCdata.lastloadout = name
			end,
		},
		["psaveloadout"] = {
			["Description"] = "Saves your current inventory to a custom loadout [name]",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local core = game:GetService("CoreGui"):FindFirstChild("RobloxGui")
				local loadname = table.concat(args, " ")
				if loadname == "" then loadname = _G.PLCdata.lastloadout end
				if core then
					if not loadname then
						notify("Invalid", "Please enter a loadout name")
						return
					end
					loadname = loadname:lower()
					local list = {}
					for i, item in pairs(core.Backpack.Hotbar:GetChildren()) do
						local name = item.ToolName.Text
						if name then
							list[i] = name
						else
							list[i] = 0
						end
					end
					formatFile()
					local data = JSONload()
					data.Loadouts[loadname] = list
					JSONsave(data)
					notify("Saved", "Saved your inventory to "..loadname)
					_G.PLCdata.lastloadout = loadname
				else
					notify("No gui", "Coulden't find the roblox gui and loadout did not save")
				end
			end,
		},
		["pdeletloadout"] = {
			["Description"] = "Delets this custon loadout [name]",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local loadname = table.concat(args, " ")
				if loadname == "" then loadname = _G.PLCdata.lastloadout end
				if not loadname then
					notify("Invalid", "Please enter a loadout name")
					return
				end
				loadname = loadname:lower()
				formatFile()
				local data = JSONload()
				data.Loadouts[loadname] = nil
				JSONsave(data)
				notify("Removed", "Removed the loadout "..loadname)
				_G.PLCdata.lastloadout = loadname
			end,
		},
		["ploadgunmod"] = {
			["Description"] = "Gives you your gun mod [name]",
			["Aliases"] = {"ploadmod"},
			["Function"] = function(args, speaker)
				local name = string.lower(table.concat(args, " "))
				if name == "" then name = _G.PLCdata.lastgunmod end
				formatFile()
				local data = JSONload()
				local found = data["Gunmods"][name]
				if not found then
					notify("Invalid", "Please enter a valid gunmod name")
					return
				end
				local current = Players.LocalPlayer.Character
				local function modify(gun)
					local mod = gun:FindFirstChildOfClass("ModuleScript")
					if mod then
						local sM = require(mod)
						if found["Firerate"] ~= "N" then
							savemod(gun, "Firerate", found["Firerate"])
							sM["FireRate"] = found["Firerate"]
						end
						if found["BulletAmount"] ~= "N" then
							savemod(gun, "BulletAmount", found["BulletAmount"])
							sM["Bullets"] = found["BulletAmount"]
						end
						if found["Spread"] ~= "N" then
							savemod(gun, "Spread", found["Spread"])
							sM["Spread"] = found["Spread"]
						end
						if found["Range"] ~= "N" then
							savemod(gun, "Range", found["Range"])
							sM["Range"] = found["Range"]
						end
						if found["Auto"] ~= "N" then
							savemod(gun, "Auto", found["Auto"])
							sM["AutoFire"] = found["Auto"]
						end
						if found["NoReloadtime"] then
							savemod(gun, "NoReloadtime", true)
							sM["ReloadTime"] = 0
						end
						local interface = gun.GunInterface
						gun.Parent = Players.LocalPlayer.Backpack
						interface.Disabled = true
						RS.Heartbeat:Wait()
						interface.Disabled = false
					end
				end
				local gun = Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
				if gun then
					modify(gun)
				else
					for _, v in pairs(Players.LocalPlayer.Backpack:GetChildren()) do
						modify(v)
					end
				end
				_G.PLCdata.lastgunmod = name
			end,
		},
		["pgunwithgunmod"] = {
			["Description"] = "Gives you a gun with the gun mod applied [gun] [name]",
			["Aliases"] = {"ploadgunwithgunmod", "pgunwmod"},
			["Function"] = function(args, speaker)
				local name = string.lower(table.concat(args, " ", 2))
				if name == "" then name = _G.PLCdata.lastgunmod end
				formatFile()
				local data = JSONload()
				local found = data["Gunmods"][name]
				if not found then
					notify("Invalid", "Please enter a valid gunmod name")
					return
				end
				local input = args[1]
				local item = nil
				for _, f in pairs(possibleItems) do
					if string.sub(f:lower(), 1, input:len()) == input:lower() then
						item = f
					end
				end
				local succsses = false
				local remote = workspace.Remote.ItemHandler
				local folder = workspace.Prison_ITEMS
				for _, sec in pairs(folder:GetChildren()) do
					local found = sec:FindFirstChild(item)
					if found then
						local pickup = found:FindFirstChild("ITEMPICKUP")
						if pickup then
							remote:InvokeServer(pickup)
							succsses = true
							break
						else
							notify("Cant pick up", "Couldent pick up "..item)
							succsses = true
							break
						end
					end
				end
				if not succsses then
					notify("Cant find", "Couldent find "..item)
					return
				end
				local current = Players.LocalPlayer.Character
				local gun = Players.LocalPlayer.Backpack:FindFirstChild(item)
				local mod = gun:FindFirstChild("GunStates")
				if mod then
					local sM = require(mod)
					if found["Firerate"] ~= "N" then
						savemod(gun, "Firerate", found["Firerate"])
						sM["FireRate"] = found["Firerate"]
					end
					if found["BulletAmount"] ~= "N" then
						savemod(gun, "BulletAmount", found["BulletAmount"])
						sM["Bullets"] = found["BulletAmount"]
					end
					if found["Spread"] ~= "N" then
						savemod(gun, "Spread", found["Spread"])
						sM["Spread"] = found["Spread"]
					end
					if found["Range"] ~= "N" then
						savemod(gun, "Range", found["Range"])
						sM["Range"] = found["Range"]
					end
					if found["Auto"] ~= "N" then
						savemod(gun, "Auto", found["Auto"])
						sM["AutoFire"] = found["Auto"]
					end
					if found["NoReloadtime"] then
						savemod(gun, "NoReloadtime", found["NoReloadtime"])
						sM["ReloadTime"] = found["NoReloadtime"]
					end
					local interface = gun.GunInterface
					gun.Parent = Players.LocalPlayer.Backpack
					interface.Disabled = true
					RS.Heartbeat:Wait()
					interface.Disabled = false
				end
				_G.PLCdata.lastgunmod = name
			end,
		},
		["psavegunmod"] = {
			["Description"] = "Save this custom gun mod (HOLD GUN) [name]",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local name = table.concat(args, " ")
				if name == "" then name = _G.PLCdata.lastgunmod end
				if not name then
					notify("Invalid", "Please enter a gunmod name")
					return
				end
				local current = Players.LocalPlayer.Character
				local gun = current:FindFirstChildOfClass("Tool")
				if not gun then
					notify("Invalid", "Please hold out your gun")
					return
				end
				local sM = gun:FindFirstChild("GunStates")
				if sM then
					name = name:lower()
					formatFile()
					local data = JSONload()
					local t = require(sM)["PLCModifications"]
					data.Gunmods[name] = t
					JSONsave(data)
					notify("Saved", "Saved your gunmod to "..name)
					_G.PLCdata.lastgunmod = name
				else
					notify("Invalid", "This gun doesn't have modifications. Or it's not a gun")
				end
			end,
		},
		["pdeletgunmod"] = {
			["Description"] = "Delets this custom gun mod [name]",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local name = table.concat(args, " ")
				if name == "" then name = _G.PLCdata.lastgunmod end
				if not name then
					notify("Invalid", "Please enter a gunmod name")
					return
				end
				name = name:lower()
				formatFile()
				local data = JSONload()
				data.Gunmods[name] = nil
				JSONsave(data)
				notify("Removed", "Removed the gunmod "..name)
				_G.PLCdata.lastgunmod = name
			end,
		},
		["pfixfade"] = {
			["Description"] = "Fixes the fadeing screen and makes it transparent",
			["Aliases"] = {"prestorefade"},
			["Function"] = function(args, speaker)
				local home = Players.LocalPlayer.PlayerGui:FindFirstChild("Home")
				if home then
					local fade = home:FindFirstChild("fadeFrame")
					if fade then
						fade.BackgroundTransparency = 1
					end
				end
			end,
		},
		["ptase"] = {
			["Description"] = "Tases somebody [plr]",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local Color = tostring(Players.LocalPlayer.TeamColor)
				local waiting = true
				local c = 0
				Team("g")
 				repeat
					c = c + 1
					if tostring(Players.LocalPlayer.TeamColor) == "Bright blue" then
						waiting = false
					end
					if c > 240 then
						break
					end 
					RS.Heartbeat:Wait()
				until not waiting
				if not waiting then
					Respawn()
					local Taser = Players.LocalPlayer.Backpack:FindFirstChild("Taser") or Players.LocalPlayer.Character:FindFirstChild("Taser")
					local rargs = {
						[1] = {},
						[2] = Taser
					}	
					for _, plr in pairs(getPlayer(args[1], speaker)) do
						plr = Players[plr]
						local Hit = plr.Character:FindFirstChild("Head")--getRoot(plr.Character) or plr.Character:FindFirstChildOfClass("BasePart")
						local arg = {
							["RayObject"] = Ray.new(Vector3.new(827.41241455078, 101.48977661133, 2296.8432617188), Vector3.new(277.73867797852, 6.8934092521667, 287.7737121582)),
							["Distance"] = 4.7204174995422,
							["Cframe"] = CFrame.new(Vector3.new(832.04937744141, 101.39200592041, 2300.9716796875), Vector3.new(-0.53363537788391, -0.10343056917191, -0.83936601877213)),
						 	["Hit"] = Hit,
						}
						table.insert(rargs[1], #rargs[1]+1, arg)
					end
					game:GetService("ReplicatedStorage").ShootEvent:FireServer(unpack(rargs))
					wait()
					TeamColor(Players.LocalPlayer, {Color})
				else
					notify("Couldent tase", "Took too long to switch to cops team, or its full")
				end
			end,
		},
		["pmodgun"] = {
			["Description"] = "Mods your selected gun. Or all if no gun is held [rate] [amount] [auto y\n]",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local rate = tonumber(args[1]) or 0
				local amount = tonumber(args[2]) or 1
				local auto = true
				if args[3] and args[3]:lower() == "n" then
					auto = false
				end
				local function modify(gun)
					local mod = gun:FindFirstChildOfClass("ModuleScript")
					if mod then
						local sM = require(mod)
						sM["FireRate"] = rate
						sM["AutoFire"] = auto
						sM["Bullets"] = amount
					end
					savemod(gun, "Firerate", rate)
					savemod(gun, "Auto", auto)
					savemod(gun, "BulletAmount", amount)
				end
				local gun = Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
				if gun then
					modify(gun)
				else
					for _, v in pairs(Players.LocalPlayer.Backpack:GetChildren()) do
						modify(v)
					end
				end
			end,
		},
		["pspread"] = {
			["Description"] = "Changes spread of your selected gun. Or all if no gun is held (great = less spread) [spread]",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local spread = tonumber(args[1]) or 0
				local function modify(gun)
					local mod = gun:FindFirstChildOfClass("ModuleScript")
					if mod then
						local sM = require(mod)
						sM["Spread"] = spread
						local interface = gun.GunInterface
						gun.Parent = Players.LocalPlayer.Backpack
						interface.Disabled = true
						RS.Heartbeat:Wait()
						interface.Disabled = false
						savemod(gun, "Spread", spread)
					end
				end
				local gun = Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
				if gun then
					modify(gun)
				else
					for _, v in pairs(Players.LocalPlayer.Backpack:GetChildren()) do
						modify(v)
					end
				end
			end,
		},
		["prange"] = {
			["Description"] = "Changes range of your selected gun. Or all if no gun is held (defaults to 2480) [range]",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local range = tonumber(args[1]) or 2480
				local function modify(gun)
					local mod = gun:FindFirstChildOfClass("ModuleScript")
					if mod then
						local sM = require(mod)
						sM["Range"] = range
						local interface = gun.GunInterface
						gun.Parent = Players.LocalPlayer.Backpack
						interface.Disabled = true
						RS.Heartbeat:Wait()
						interface.Disabled = false
						savemod(gun, "Range", range)
					end
				end
				local gun = Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
				if gun then
					modify(gun)
				else
					for _, v in pairs(Players.LocalPlayer.Backpack:GetChildren()) do
						modify(v)
					end
				end
			end,
		},
		["pnoreloadtime"] = {
			["Description"] = "Mods your selected gun to have fast reload. Or all if no gun is held",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local function modify(gun)
					local mod = gun:FindFirstChildOfClass("ModuleScript")
					if mod then
						local sM = require(mod)
						sM["ReloadTime"] = 0
						savemod(gun, "NoReloadtime", true)
					end
				end
				local gun = Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
				if gun then
					modify(gun)
				else
					for _, v in pairs(Players.LocalPlayer.Backpack:GetChildren()) do
						modify(v)
					end
				end
			end,
		},
		["pinfammo"] = {
			["Description"] = "Gives the gun infinite ammo. Or all if no gun is held",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local function reload(gun)
					game:GetService("ReplicatedStorage").ReloadEvent:FireServer(gun)
					local mod = gun:FindFirstChildOfClass("ModuleScript")
					if mod then
						local sM = require(mod)
						sM["CurrentAmmo"] = sM["MaxAmmo"]
					end
				end
				local function modify(gun)
					spawn(function()
						while gun and gun.Parent and gun ~= nil and gun.Parent ~= nil do
							RS.RenderStepped:Wait()
							local mod = gun:FindFirstChildOfClass("ModuleScript")
							local sM = require(mod)
							if sM["CurrentAmmo"] <= 0 then
								reload(gun)
							end
						end
					end)
				end
				local gun = Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
				if gun then
					modify(gun)
				else
					for _, v in pairs(Players.LocalPlayer.Backpack:GetChildren()) do
						modify(v)
					end
				end
			end,
		},
		["pswatak"] = {
			["Description"] = "Makes your AK-47 act like a M4A1",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local gun = Players.LocalPlayer.Backpack:FindFirstChild("AK-47") or Players.LocalPlayer.Character:FindFirstChild("AK-47")
				if gun then
					local data = {
						Damage = 11, 
						Description = "Remember to put a description here BEFORE the game is published -Me", 
						MaxAmmo = 30, 
						CurrentAmmo = 30, 
						StoredAmmo = 600, 
						AutoFire = true, 
						Range = 800, 
						Spread = 18,
						FireRate = 0.0875, 
						ReloadTime = 2, 
						Bullets = 1, 
						ReloadAnim = "ReloadMagazine", 
						ShootAnim = "ShootBullet", 
						HoldAnim = "Hold", 
						FireSoundId = "http://www.roblox.com/asset/?id=2934888536", 
						SecondarySoundId = nil, 
						ReloadSoundId = "http://www.roblox.com/asset/?id=2934887229"
					}
					local mod = gun:FindFirstChildOfClass("ModuleScript")
					local sM = require(mod)
					sM["FireRate"] = 0.0875
					sM["FireSoundId"] = "rbxassetid://2934888536"
					gun.Name = "M4A1"
					gun.Handle.FireSound.SoundId = "rbxassetid://2934888536"
				end
			end,
		},
		["pearape"] = {
			["Description"] = "Makes a loud sound for everyone",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				if loudsound then
					loudsound = false
					notify("Earape", "Loud noise stopped")
				else
					loud()
					notify("Earape", "Loud noise started")
				end
			end,
		},
		["padmin"] = {
			["Description"] = "Admins a peep til you rejoin",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local targets = getPlayer(args[1], speaker)
				for _, plr in pairs(targets) do
					if not table.find(_G.PLCdata.admin.admins, plr) then
						table.insert(_G.PLCdata.admin.admins, plr)
					end
				end
			end,
		},
		["punadmin"] = {
			["Description"] = "Unadmins a peep til you rejoin. Unless you admined them",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local targets = getPlayer(args[1], speaker)
				for _, plr in pairs(targets) do
					local plr = table.find(_G.PLCdata.admin.admins, plr)
					if plr then
						table.remove(_G.PLCdata.admin.admins, plr)
					end
				end
				local a = args[1]:lower()
				for i, plr in pairs(_G.PLCdata.admin.admins) do
					if string.sub(plr, 1, a:len()):lower() == a then
						table.remove(_G.PLCdata.admin.admins, i)
					end
				end
			end,
		},
		["pgetadmins"] = {
			["Description"] = "Tells you admins in chat",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				game:GetService("StarterGui"):SetCore("ChatMakeSystemMessage", {Text = "Admins list:"})
				for _, plr in pairs(_G.PLCdata.admin.admins) do
					if not table.find(_G.PLCdata.admin.superadmins, plr) then
						local col = nil
						if Players:FindFirstChild(plr) then
							col = Color3.fromRGB(255, 255, 41)
						else
							col = Color3.fromRGB(171, 171, 171)
						end
						game:GetService("StarterGui"):SetCore("ChatMakeSystemMessage", {Text = plr..": Admin", Color = col})
					end
				end
				for _, plr in pairs(_G.PLCdata.admin.superadmins) do
					local col = nil
					if Players:FindFirstChild(plr) then
						col = Color3.fromRGB(247, 45, 45)
					else
						col = Color3.fromRGB(171, 171, 171)
					end
					game:GetService("StarterGui"):SetCore("ChatMakeSystemMessage", {Text = plr..": Super Admin", Color = col})
				end
			end,
		},
		["pcar"] = {
			["Description"] = "Spawn a car where the speaker is at",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local type = "Squad"
				local button = nil
				for _, v in pairs(workspace["Prison_ITEMS"].buttons:GetChildren()) do
					if v.Name == "Car Spawner" then
						if v["Car Spawner"].type.Value == type then
							button = v["Car Spawner"]
						end
					end
				end
				spawn(function()
					workspace.Remote.ItemHandler:InvokeServer(button)
				end)
				local car = nil
				local con = workspace.CarContainer.ChildAdded:Connect(function(c)
					car = c
				end)
				local WT = elapsedTime() + 4
				repeat
					RS.RenderStepped:Wait()
				until car or elapsedTime() > WT
				con:Disconnect()
				wait()
				if car then
					car:WaitForChild("Body"):WaitForChild("VehicleSeat"):WaitForChild("ReadyToSpawn")
					local wheels = car.Wheels
					local seat = car.Body.VehicleSeat
					local root = getRoot(Players.LocalPlayer.Character)
					local hum = Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
					local root2 = getRoot(speaker.Character)
					local offset = CFrame.new(0, 1, 0) * CFrame.Angles(0, math.rad(90), math.rad(90))
					local pos = root2.CFrame * offset
					local looping = true
					local up = true
					RS:BindToRenderStep("PLCcarattach", 1, function()
						if up then
							root.CFrame = CFrame.new(seat.Position + Vector3.new(1, 1, 1))
						else
							root.CFrame = CFrame.new(seat.Position)
						end
						if hum.SeatPart ~= seat then
							hum.Sit = false
						end
						up = not up
					end)
					seat:GetPropertyChangedSignal("Occupant"):Wait()
					RS:UnbindFromRenderStep("PLCcarattach")
					looping = false
					car.PrimaryPart = car.Body.Main
					car:SetPrimaryPartCFrame(pos)
					for _, wheel in pairs(wheels:GetChildren()) do
						wheel.CFrame = pos
						wheel.Anchored = true
					end
					wait(0.1)
					for _, wheel in pairs(wheels:GetChildren()) do
						wheel.Anchored = false
					end
				else
					notify("Can't spawn", "Took to long to spawn a car. Is the server lagging?")
				end
			end,
		},
		["pdeletcar"] = {
			["Description"] = "Attemps to delets the car you're in, if it fails it removes ur drivers license til you respawn",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local hum = Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
				local seat = hum.SeatPart
				if seat then
					local car = seat.Parent.Parent
					if car then
						local wheels = car.Wheels
						local root = getRoot(Players.LocalPlayer.Character)
						local current = root.CFrame
						car.PrimaryPart = car.Body.Main
						local delet = Instance.new("BodyPosition", car.PrimaryPart)
						delet.Position = (void * CFrame.new(0, 500, 0)).Position
						delet.MaxForce = Vector3.new("inf", "inf", "inf")
						wait(1)
						hum.Sit = false
						delet:Destroy()
						local CT = os.clock() + 0.4
						while CT > os.clock() do
							RS.RenderStepped:Wait()
							hum.Sit = false
							root.CFrame = current
							root.Velocity = Vector3.new(0, 0, 0)
							if not seat or seat.Parent == nil then
								break
							end
						end
					end
				end
			end,
		},
		["ptogglefastbring"] = {
			["Description"] = "Toggles the fastbring mode [on/off]",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local arg = tostring(args[1]):lower()
				if arg == "on" then
					_G.PLCdata.fastbring = true
					notfiy("Enabled", "Fastbring was enabled")
				elseif arg == "off" then
					_G.PLCdata.fastbring = false
					notfiy("Disabled", "Fastbring was disabled")
				else
					notfiy("Invalid", "Invalid argument. Do 'on/off'")
				end
			end,
		},
		["pfasteat"] = {
			["Description"] = "You can eat fast and a lot (hold food)",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local character = Players.LocalPlayer.Character
				local tool = character:FindFirstChildOfClass("Tool")
				tool.LocalScript.Disabled = true
				tool.Equipped:connect(function(p1)
					p1.Button1Down:connect(function()
						tool.Handle.EatSound:Play()
						character.Humanoid:LoadAnimation(tool.Animation):Play()
						character.Humanoid.Health = character.Humanoid.Health + 15
					end)
				end)
				character.Humanoid:UnequipTool(tool)
			end,
		},
		["pantitase"] = {
			["Description"] = "Well, you cant get tased. Doesent get any simpler than that",
			["Aliases"] = {"pnotase"},
			["Function"] = function(args, speaker)
				if getconnections then
					local connections = getconnections(workspace.Remote.tazePlayer.OnClientEvent)
					for _, con in pairs(connections) do
						con:Disable()
					end
					notify("Anti-tase", "Those annoying taser spammers are no match for you")
				else
					notify("Incompatible Exploit", "Your exploit does not support this command (missing getconnections) and anti-tase will not work")
				end
			end,
		},
		["panticrash"] = {
			["Description"] = "Prevents you from being crash by bullet spam (You can't see bullet rays though)",
			["Aliases"] = {"pnocrash"},
			["Function"] = function(args, speaker)
				if getconnections then
					if args[1] then
						local enabled = args[1]:lower()
						local rem = game:GetService("ReplicatedStorage"):WaitForChild("ReplicateEvent")
						local connections = getconnections(rem.OnClientEvent)
						if enabled == "on" then
							for _, con in pairs(connections) do
								con:Disable()
							end
							notify("Anti-crash", "Anti crash was enabled")
						elseif enabled == "off" then
							for _, con in pairs(connections) do
								con:Enable()
							end
							notify("Anti-crash", "Anti crash was disabled")
						else
							notify("Invalid", "Invalid args. (Do on/off)")
						end
					end
					
				else
					notify("Incompatible Exploit", "Your exploit does not support this command (missing getconnections) and anti-crash will not work")
				end
			end,
		},
		["pcamlookat"] = {
			["Description"] = "temporary lol",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local t = Players:FindFirstChild(getPlayer(args[1], speaker)[1])
				if t and t.Character and t.Character.Head then
					workspace.CurrentCamera.CFrame = CFrame.new(workspace.CurrentCamera.CFrame.Position, t.Character.Head.Position)
				end
			end,
		},
		["pvirus"] = {
			["Description"] = "Makes the player like a lava brick",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local targets = getPlayer(args[1], speaker)
				for _, v in ipairs(targets) do
					local target = Players[v]
					local name = "GIVE_VIRUS_"..target.Name
					local processing = {}
					local function find(v)
						for _, i in pairs(processing) do
							if i[1] == v then
								return true
							end
						end
						return
					end
					UnbindRender(name)
					BindRender(name, function()
						if not target then
							UnbindRender(name)
						end
						if not cooldown and target.Character then
							for _, plr in pairs(Players:GetPlayers()) do
								if IsAlive(plr) and IsVulnerable(plr) and IsClose(plr, target, 3) and plr ~= target and plr ~= Players.LocalPlayer and not find(plr.Character) then
									table.insert(processing, {plr.Character, os.clock() + 2})
									GunKill(plr.Name)
								end
							end
						end
						local new = data
						for i, data in pairs(processing) do
							if not data then
								return
							end
							if data[2] < os.clock() then
								new[i] = nil
							end
						end
						data = new
					end)
				end
			end,
		},
		["punvirus"] = {
			["Description"] = "Removes virus from a player",
			["Aliases"] = {"pcure"},
			["Function"] = function(args, speaker)
				local targets = getPlayer(args[1], speaker)
				for _, v in ipairs(targets) do
					local target = Players[v]
					local name = "GIVE_VIRUS_"..target.Name
					UnbindRender(name)
				end
			end,
		},
		["pgivearua"] = {
			["Description"] = "Gives kill arua to a player",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local targets = getPlayer(args[1], speaker)
				for _, v in ipairs(targets) do
					local target = Players[v]
					local name = "GIVE_KILL_ARUA_"..target.Name
					local processing = {}
					local function find(v)
						for _, i in pairs(processing) do
							if i[1] == v then
								return true
							end
						end
						return
					end
					UnbindRender(name)
					BindRender(name, function()
						if not target then
							UnbindRender(name)
						end
						if not cooldown and target.Character then
							for _, plr in pairs(Players:GetPlayers()) do
								if IsAlive(plr) and IsVulnerable(plr) and IsClose(plr, target) and plr ~= target and plr ~= Players.LocalPlayer and not find(plr.Character) then
									table.insert(processing, {plr.Character, os.clock() + 2})
									GunKill(plr.Name)
								end
							end
						end
						local new = data
						for i, data in pairs(processing) do
							if not data then
								return
							end
							if data[2] < os.clock() then
								new[i] = nil
							end
						end
						data = new
					end)
				end
			end,
		},
		["premovearua"] = {
			["Description"] = "Removes kill arua from a player",
			["Aliases"] = {"pcure"},
			["Function"] = function(args, speaker)
				local targets = getPlayer(args[1], speaker)
				for _, v in ipairs(targets) do
					local target = Players[v]
					local name = "GIVE_KILL_ARUA_"..target.Name
					UnbindRender(name)
				end
			end,
		},
		["pjoinjobid"] = {
			["Description"] = "Join a server from a jobid",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, table.concat(args, " "), Players.LocalPlayer)
			end,
		},
		["pkey"] = {
			["Description"] = "Give somebody or yourself a keycard",
			["Aliases"] = {},
			["Function"] = function(args, speaker)
				local Color = tostring(Players.LocalPlayer.TeamColor)
				local waiting = true
				local c = 0
				Team("g")
 				repeat
					c = c + 1
					if Players.LocalPlayer.TeamColor == BrickColor.new("Bright blue") then
						waiting = false
					end
					if c > 240 then
						break
					end 
					RS.Heartbeat:Wait()
				until not waiting
				if not waiting then
					local pickup = nil
					for _, v in ipairs(getPlayer(args[1], speaker)) do
						local target = Players[v]
						local attempts = 0
						local found = workspace["Prison_ITEMS"].single:FindFirstChild("Key card")
						while attempts < 10 and not found and target do
							Players.LocalPlayer.Character:BreakJoints()
							Respawn()
							found = workspace["Prison_ITEMS"].single:FindFirstChild("Key card")
							attempts = attempts + 1
						end
						if found and target then
							pickup = found:FindFirstChild("ITEMPICKUP")
							if pickup and target and target ~= Players.LocalPlayer and IsAlive(target) then
								workspace.Remote.ItemHandler:InvokeServer(pickup)
								local NormPos = getRoot(Players.LocalPlayer.Character).CFrame
								local tool = Players.LocalPlayer.Backpack:WaitForChild("Key card")
								tool.Parent = Players.LocalPlayer.Backpack
								attach(Players.LocalPlayer, target, tool)
								Respawn(NormPos)
							end
						end
					end
					TeamColor(Players.LocalPlayer, {Color})
					if not args[1] or args[1]:len() == 0 then
						workspace.Remote.ItemHandler:InvokeServer(pickup)
					end
				else
					notify("Couldent give/get key", "Took too long to switch to cops team, or its full")
				end
			end,
		},
		["pclickkill"] = {
			["Description"] = "Get a click to kill tool",
			["Aliases"] = {"pck"},
			["Function"] = function(args, speaker)
				local CK = Instance.new("Tool", Players.LocalPlayer.Backpack)
				CK.Name = "CK"
				CK.RequiresHandle = false
				CK.Equipped:Connect(function(mouse)
					mouse.Button1Down:Connect(function()
						local target = mouse.Target
						local char = target.Parent
						local plr = Players:GetPlayerFromCharacter(char) or Players:GetPlayerFromCharacter(char.Parent)
						if plr then
							GunKill(plr.Name)
						end
					end)
				end)
			end,
		},
		["panticrim"] = {
			["Description"] = "Prevents you form becomeing a criminal",
			["Aliases"] = {"pnocrim"},
			["Function"] = function(args, speaker)
				local arg = args[1]:lower()
				if arg == "on" then
					anticrim = true
					notify("Enabled", "Anti-crim was turned on (Server will make you crim if you're inmate and escaped)")
				elseif arg == "off" then
					anticrim = false
					notify("Disabled", "Anti-crim was turned off")
				else
					notify("Invalid", "Invalid argument. Do 'on/off'")
				end
			end,
		},
		["pantibring"] = {
			["Description"] = "Prevents bring people from bringing you",
			["Aliases"] = {"pnobring"},
			["Function"] = function(args, speaker)
				local arg = args[1]:lower()
				if arg == "on" then
					antibring = true
					notify("Enabled", "Anti-bring was turned on")
				elseif arg == "off" then
					antibring = false
					notify("Disabled", "Anti-bring was turned off")
				else
					notify("Invalid", "Invalid argument. Do 'on/off'")
				end
			end,
		},
		--TEMP REMOVE













		["pclickcrim"] = {
			["Description"] = "Prevents bring people from bringing you",
			["Aliases"] = {"pnobring"},
			["Function"] = function(args, speaker)
				local function Touch(x, Root) -- IY touch function
				if firetouchinterest then
						return spawn(function()
							firetouchinterest(x, Root, 1, wait() and firetouchinterest(x, Root, 0))
						end)
					else
						notify("Incompatible Exploit","Your exploit does not support this command (missing firetouchinterest) this is need to touch the criminal pad")
					end
					x.CFrame = Root.CFrame
				end

				local CK = Instance.new("Tool", game.Players.LocalPlayer.Backpack)
				CK.Name = "CK"
				CK.RequiresHandle = false
				CK.Equipped:Connect(function(mouse)
					mouse.Button1Down:Connect(function()
						local target = mouse.Target
							Touch(workspace["Criminals Spawn"].SpawnLocation, target)
					end)
				end)
			end,
		},
			
	},
}

local Prefix = ":"
--[[

local BasicList = {
	"List of commands, <PRE>crim -Makes the player a crim, <PRE>pris -Brings you to the hosts position, <PRE>death -Toggles loud noise, <PRE>tp -Teleports a player to a player",
	"<PRE>goto -Teleports you to a player, <PRE>bring -Brings a player, <PRE>tase -Tases a player, <PRE>k -Ends a player, <PRE>sk -Ends a player but slower",
	", <PRE>arrest -Arrests a player, <PRE>virus -Makes a player like a lava brick <PRE>arua -Gives the player a deadly arua <PRE>unvirus -Removes virus from a player",
	"<PRE>unarua - Removes arua from a player"
}
local SuperList = {
	"List of super commands, <PRE>crash -Trys to crash the everyone, <PRE>admin -Adds people to admin list, <PRE>unadmin -Removes a players admin",
}

]]

-- Simplified
local BasicList = {
	"List of commands, <PRE>crim [plr] <PRE>pris [plr] <PRE>death <PRE>tp [plr] [plr to] <PRE>goto [plr] <PRE>bring [plr] <PRE>tase [plr] <PRE>k [plr]",
	"<PRE>sk [plr] <PRE>arrest [plr] <PRE>virus [plr] <PRE>ka [plr] <PRE>unvirus [plr] <PRE>oka [plr] <PRE>key [plr]"
}
local SuperList = {
	"List of super commands, <PRE>crash <PRE>admin [plr] <PRE>unadmin [plr]",
}

for i, cmd in pairs(BasicList) do
	if cmd then
		BasicList[i] = table.concat(cmd:split("<PRE>"), Prefix)
	end
end
for i, cmd in pairs(SuperList) do
	if cmd then
		SuperList[i] = table.concat(cmd:split("<PRE>"), Prefix)
	end
end

local prefix = _G.PLCdata.admin.prefix
local cmds = {}
for n, d in pairs(PLC["Commands"]) do
	cmds[n] = d
end
local function Run(cmd, args, speaker)
	cmds[cmd]["Function"](args, speaker)
end

local function Chat(msg)
	game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(msg, "All")
end

local function Added(plr)
	plr.Chatted:Connect(function(msg)
		if msg:len() > 512 then
			return
		end
		local isSuper = table.find(_G.PLCdata.admin.superadmins, plr.Name)
		local isBasic = (_G.PLCdata.admin.everyone and not table.find(_G.PLCdata.admin.blacklisted, plr.Name)) or table.find(_G.PLCdata.admin.admins, plr.Name) or isSuper
		if isBasic then
			local isLoudPrefix = string.sub(msg, 1, Prefix:len()):lower() == Prefix
			local isSilentrefix = string.sub(msg, 1, Prefix:len() + 3):lower() == "/e "..Prefix
			if isLoudPrefix or isSilentPrefix then
				local Prefix = Prefix
				if isSilentPrefix then
					Prefix = "/e "..Prefix
				end
				local values = msg:split(Prefix)[2]:split(" ")
				local command = values[1]:lower()
				local args = {}
				for i, arg in pairs(values) do
					if i > 1 then
						args[#args+1] = arg
					end
				end
				if command == "cmds" then
					for _, cmd in pairs(BasicList) do
						Chat("/w "..plr.Name.." "..cmd, "All")
					end
				elseif command == "death" then
					Run("pearape")
				elseif command == "crim" then
					Run("pcriminal", args, plr)
				elseif command == "pris" then
					Run("pbring", args, plr)
				elseif command == "goto" then
					local t = {plr.Name, args[1]}
					Run("pteleport", t, plr)
				elseif command == "bring" then
					local t = {args[1], plr.Name}
					Run("pteleport", t, plr)
				elseif command == "tp" then
					Run("pteleport", args)
				elseif command == "tase" then
					Run("ptase", args, plr)
				elseif command == "k" then
					Run("pfastkill", args, plr)
				elseif command == "sk" then
					Run("pkill", args, plr)
				elseif command == "arrest" then
					Run("parrest", args, plr)
					args[2] = math.clamp(tonumber(args[2]) or 1, 0, 1000)
				elseif command == "virus" then
					Run("pvirus", args, plr)
				elseif command == "unvirus" then
					Run("punvirus", args, plr)
				elseif command == "ka" then
					Run("pgivearua", args, plr)
				elseif command == "oka" then
					Run("premovearua", args, plr)
				elseif command == "key" then
					Run("pkey", args, plr)
				end
				if isSuper then
					if command == "super" then
						for _, cmd in pairs(SuperList) do
							Chat("/w "..plr.Name.." "..cmd, "All")
						end
					elseif command == "crash" then
						Run("pcrash")
					elseif command == "admin" then
						Run("padmin", args, plr)
					elseif command == "unadmin" then
						Run("punadmin", args, plr)
					end
				end
			end
		end
	end)
end

local isPL = game.PlaceId == 155615604

if not game:IsLoaded() then
	game.Loaded:Wait()
end
if not _G.PLCdataadminloaded and isPL then
	_G.PLCdataadminloaded = true
	for _, plr in pairs(Players:GetPlayers()) do
		Added(plr)
	end
	Players.PlayerAdded:Connect(Added)
end

--[[rconsoleclear()
function p(...)
	for _, m in pairs({...}) do
		rconsoleprint(tostring(m).." ")
	end
	rconsoleprint("\n")
end
for n, c in pairs(PLC["Commands"]) do
	p(n, unpack(c["Aliases"]), c["Description"])
end]]

local addcases = {
	["visible"] = function(speaker,args)
		local returns = {}
		local speakerChar = speaker.Character
		if not speakerChar or not getRoot(speakerChar) then return end
		for _, plr in pairs(Players:GetPlayers()) do
			if plr.Character and getRoot(plr.Character) then
				local raystart = getRoot(speakerChar).Position
				local rayend = getRoot(plr.Character).Position
				local raydirection = rayend - raystart
				local ray = Ray.new(raystart, raydirection)
				local rayhit = workspace:FindPartOnRayWithIgnoreList(ray, {speakerChar})
				if rayhit and rayhit:IsDescendantOf(plr.Character) then
					table.insert(returns,plr)
				end
			end
		end
		return returns
	end,
	["forcefield"] = function(speaker,args)
		local returns = {}
		for _, plr in pairs(Players:GetPlayers()) do
			if plr.Character and plr.Character:FindFirstChildOfClass("ForceField") then
				table.insert(returns,plr)
			end
		end
		return returns
	end
}

for name, case in pairs(addcases) do
	getfenv()["SpecialPlayerCases"][name] = case
end

local all = {
	"pfastcar",
	"pgetcolor",
	"pjoinjobid"
}

if not isPL then
	for i, cmd in pairs(PLC.Commands) do
		if not table.find(all, i) then
			PLC.Commands[i] = nil
		end
	end
	local info = "This game isen't prison life and only all game comands are added"
	PLC.Commands["PLCREADME"] = {
		["Description"] = info,
		["Aliases"] = {},
		["Function"] = function()
			notify("Notification", info)
		end
	}
end

local replace = _G.PLCdata.cmdreplace
local copy = {}
for n, d in pairs(PLC["Commands"]) do
	copy[n] = d
end
for name, data in pairs(copy) do
	if replace[name] then
		local func = data["Function"]
		local desc = data["Description"]
		local aliases = replace[name]["Aliases"]
		local newname = replace[name]["Name"]
		PLC.Commands[name] = nil
		PLC.Commands[newname] = {
			["Description"] = desc,
			["Aliases"] = aliases,
			["Function"] = func
		}
	end
end

if isPL then
	local hieght = -165
	local found = workspace:FindFirstChild("PLC - antifall")
	if found then
		found:Destroy()
	end
	local antifall = Instance.new("Model", workspace)
	antifall.Name = "PLC - antifall"
	local platform = Instance.new("Part", antifall)
	platform.Anchored = true
	platform.CFrame = CFrame.new(-128, 0 + hieght, 2048)
	platform.Size = Vector3.new(39, 1, 34)
	platform.Name = "platform"
	local stand = Instance.new("Part", antifall)
	stand.Anchored = true
	stand.CFrame = CFrame.new(-128, 2 + hieght, 2032)
	stand.Size = Vector3.new(2, 3, 2)
	stand.Name = "stand"
	local stand2 = Instance.new("WedgePart", antifall)
	stand2.Anchored = true
	stand2.CFrame = CFrame.new(-128, 4 + hieght, 2032) * CFrame.Angles(0, math.rad(180), 0)
	stand2.Size = Vector3.new(2, 1, 2)
	stand2.Name = "stand2"
	local button = Instance.new("Part", antifall)
	button.Anchored = true
	button.CFrame = CFrame.new(-128, 4.1 + hieght, 2032) * CFrame.Angles(math.rad(22.5), math.rad(-90), 0)
	button.Size = Vector3.new(1.6, 0.4, 1.6)
	button.BrickColor = BrickColor.new("Bright red")
	button.Name = "button"
	local UI = Instance.new("SurfaceGui", button)
	UI.Adornee = button
	UI.Face = "Top"
	local label = Instance.new("TextLabel", UI)
	label.Size = UDim2.new(1, 0, 1, 0)
	label.BackgroundTransparency = 1
	label.TextScaled = true
	label.Text = "Click to goto nexus"
	local CD = Instance.new("ClickDetector", button)
	CD.MouseClick:Connect(function()
		local char = Players.LocalPlayer.Character
		local root = getRoot(char) or char:FindFirstChildOfClass("BasePart")
		root.CFrame = CFrame.new(921, 100, 2374)
	end)
end

return PLC
